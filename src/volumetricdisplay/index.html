<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cubic Voxel Volumetric Display</title>
  <link rel="shortcut icon" type="image/x-png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAgCAYAAAB+ZAqzAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAF8SURBVFhHxZS9SgNREIXzBlZa+QCKrZWgnYWFWImFWGgjCNoIIlamNKVYCVaCnWBnYSf4AD7RumdhhsnNOXejxMmBj+xuvjs77P0ZVNLMGRkmZyLD5ExkmJyJDJMzkWFyJjJMzkSGyZnIMDkTGSZnIjMhb5+cNZfPb83d53cHrvevhxNeye7FlY8pGb5/0TEtMmPi6f0TLQzQcOlHao0BNqZFxiV8FSuCr7S8stY9X9/Z6+43D47cnYbD25HXwzVzWmRcunn98EKrG1tx8K/BeKuFuguLS9RrkXHJCoH4/C+cP754rZ4vLePSrBrDWrQ6aJA5ARmXZtEYpgw7EDXwa+u0goxLVhDU1hj+M7c8RuKCn+aIaZFx6Xj04EXjrkQjmBIcB7iPuxfY+HLB2/MeZFzCNMSDtaSvsdoZCHDsmBuQGRPRHF4cjw40a00BvIBN5b82NgdkmJyJDJMzkWFyJjJMzkSGyZnIMDkTGSZnIsPkTGSYnIkMk5MYND+NvPUVWz/3JAAAAABJRU5ErkJggg==">
  <style>
    a, a:link, a:visited, a:hover, a:active {
      text-decoration: inherit;
      font-family: inherit;
      font-size: inherit;
      background-color: inherit;
      color: inherit;
    }
  </style>
</head>
<body style="margin: 0; overflow: hidden; background-color: #999999; font-family: Arial, sans-serif;">
  <div id="container" style="position: absolute; left: 0; top: 0px; width: 100%; height: 100%;"></div>
  <div id="headerpanel" style="position: absolute; left: 0; top: 0; width: 100%; height: 40px; background-color: #333333;">
    <div title="complexity.zone" style="position: absolute; left: 20px; top: 0px; width: 160px; height: 40px; color: #cccccc;">
      <a href="https://complexity.zone/"><span style="color: #80cccc; font-size: 14px; line-height: 40px;">complexity.zone</span></a>
    </div>    
    <div style="position: absolute; left: 200px; top: 0px; width: 240px; height: 40px; color: #cccccc;">
      <span style="color: #cccccc; font-size: 14px; line-height: 40px;">Cubic Voxel Volumetric Display</span>
    </div>
    <div style="position: absolute; left: 450px; top: 0px; width: 30px; height: 40px; color: #cccccc;">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="position: absolute; left: 0px; top: 8px; width: 24px; height: 24px;">
        <path fill="#cccccc" d="M11,1.07C7.05,1.56 4,4.92 4,9H11M4,15A8,8 0 0,0 12,23A8,8 0 0,0 20,15V11H4M13,1.07V9H20C20,4.92 16.94,1.56 13,1.07Z" />
      </svg>
    </div>
    <div style="position: absolute; left: 480px; top: 0px; width: 450px; height: 40px; color: #cccccc;">
      <span style="color: #cccccc; font-size: 13px; line-height: 40px;">mouse-drag = rotate around object, mouse-wheel = closer/farther</span>
    </div>
    <div title="Cubic Voxel Volumetric Display at GitHub" style="position: absolute; left: 1010px; top: 10px; width: 20px; height: 20px; background-color: transparent; overflow: hidden; cursor: pointer;">
      <a href="https://github.com/TimSamshuijzen/complexityzone/tree/main/src/volumetricdisplay" target="_blank">
        <svg width="20" height="20" viewBox="0 0 1024 1024" style="width: 20px; height: 20px; background-color: transparent;">
          <path fill="#ffffff" fill-rule="evenodd" clip-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8C0 11.54 2.29 14.53 5.47 15.59C5.87 15.66 6.02 15.42 6.02 15.21C6.02 15.02 6.01 14.39 6.01 13.72C4 14.09 3.48 13.23 3.32 12.78C3.23 12.55 2.84 11.84 2.5 11.65C2.22 11.5 1.82 11.13 2.49 11.12C3.12 11.11 3.57 11.7 3.72 11.94C4.44 13.15 5.59 12.81 6.05 12.6C6.12 12.08 6.33 11.73 6.56 11.53C4.78 11.33 2.92 10.64 2.92 7.58C2.92 6.71 3.23 5.99 3.74 5.43C3.66 5.23 3.38 4.41 3.82 3.31C3.82 3.31 4.49 3.1 6.02 4.13C6.66 3.95 7.34 3.86 8.02 3.86C8.7 3.86 9.38 3.95 10.02 4.13C11.55 3.09 12.22 3.31 12.22 3.31C12.66 4.41 12.38 5.23 12.3 5.43C12.81 5.99 13.12 6.7 13.12 7.58C13.12 10.65 11.25 11.33 9.47 11.53C9.76 11.78 10.01 12.26 10.01 13.01C10.01 14.08 10 14.94 10 15.21C10 15.42 10.15 15.67 10.55 15.59C13.71 14.53 16 11.53 16 8C16 3.58 12.42 0 8 0Z" transform="scale(64)" />
        </svg>
      </a>
    </div>
  </div>
  <script>

class HTML3D {
  constructor(container, scene) {
    this.container = container;
    this.camera = new HTML3D.Camera(this, scene?.camera);
    this.sceneContainer = document.createElement('div');
    Object.assign(this.sceneContainer.style, {
      position: 'absolute',
      width: '100%',
      height: '100%',
      transformStyle: 'preserve-3d'
    });
    this.container.appendChild(this.sceneContainer);
    this.panels = [];
    if (Array.isArray(scene?.panels)) {
      for (const scenePanel of scene.panels) {
        this.panels.push(new HTML3D.Panel(this, scenePanel));
      }
    }
    this.requestRender = true;
    for (const panel of this.panels) {
      if (panel.init !== null) {
        panel.init(this, panel);
      }
    }
    window.addEventListener('resize', () => { this.requestRender = true; });
    this._thread();
  }
  export() {
    const result = {
      camera: this.camera.export(),
      panels: this.panels.map((panel) => panel.export())
    };
    return result;
  }
  import(scene) {
    this.camera.import(scene?.camera);
    for (const panel of this.panels) {
      panel.element.remove();
    }
    this.panels = [];
    if (Array.isArray(scene?.panels)) {
      for (const panel of scene.panels) {
        this.panels.push(new HTML3D.Panel(this, panel));
      }
    }
    for (const panel of this.panels) {
      if (panel.init !== null) {
        panel.init(this, panel);
      }
    }
    this.requestRender = true;
  }
  render() {
    const innerWidth = this.container.clientWidth;
    const innerHeight = this.container.clientHeight;
    const focalLength = (0.5 * innerHeight) / Math.tan((this.camera.fov * 0.5 * Math.PI) / 180);
    this.camera.render();
    this.sceneContainer.style.transform = `perspective(${focalLength}px) translateZ(${focalLength}px) ${this.camera.viewMatrix.toCSSMatrixString()} translate(${innerWidth / 2}px, ${innerHeight / 2}px)`;
    for (let i = 0, c = this.panels.length; i < c; i++) {
      this.panels[i].render();
    }
  }
  _thread() {
    if (this.camera.animate !== null) {
      this.camera.animate(this, this.camera);
    }
    if (this.requestRender) {
      this.requestRender = false;
      this.render();
    }
    for (let i = 0, c = this.panels.length; i < c; i++) {
      const panel = this.panels[i];
      if (panel.animate !== null) {
        panel.animate(this, panel);
      }
    }
    requestAnimationFrame(() => this._thread());
  }
}
{
  HTML3D.Camera = class Camera {
    constructor(html3d, camera) {
      Object.assign(this, {
        html3d: html3d,
        x: ((typeof camera?.x === 'number') ? camera.x : 0),
        y: ((typeof camera?.y === 'number') ? camera.y : 0),
        z: ((typeof camera?.z === 'number') ? camera.z : 0),
        rotationX: ((typeof camera?.rotationX === 'number') ? camera.rotationX : 0),
        rotationY: ((typeof camera?.rotationY === 'number') ? camera.rotationY : 0),
        fov: ((typeof camera?.fov === 'number') ? camera.fov : 70),
        worldMatrix: new HTML3D.Matrix4(),
        viewMatrix: new HTML3D.Matrix4(),
        userData: ((typeof camera?.userData === 'object') ? camera.userData : null),
        init: null,
        animate: null
      });
      if (typeof camera?.init === 'function') {
        this.init = camera.init;
      } else if (typeof camera?.init === 'string') {
        try {
          this.init = new Function('html3d', 'camera', camera.init);
        } catch (e) {
          this.init = null;
          console.error(e);
        }
      }
      if (this.init !== null) {
        this.init(this.html3d, this);
      }
      this.updateWorldMatrix();
      if (typeof camera?.animate === 'function') {
        this.animate = camera.animate;
      } else if (typeof camera?.animate === 'string') {
        try {
          this.animate = new Function('html3d', 'camera', camera.animate);
        } catch (e) {
          this.animate = null;
          console.error(e);
        }
      }
    }
    export() {
      const result = {
        x: this.x,
        y: this.y,
        z: this.z,
        rotationX: this.rotationX,
        rotationY: this.rotationY,
        fov: this.fov,
        userData: (this.userData !== null) ? {...this.userData} : null
      };
      if (typeof this.init === 'function') {
        result.init = this.init.toString();
        result.init = result.init.substring(result.init.indexOf('{') + 1, result.init.lastIndexOf('}')).trim();
      }
      if (typeof this.animate === 'function') {
        result.animate = this.animate.toString();
        result.animate = result.animate.substring(result.animate.indexOf('{') + 1, result.animate.lastIndexOf('}')).trim();
      }
      return result;
    }
    import(camera) {
      this.x = (camera?.x !== undefined) ? camera.x : 0;
      this.y = (camera?.y !== undefined) ? camera.y : 0;
      this.z = (camera?.z !== undefined) ? camera.z : 0;
      this.rotationX = (camera?.rotationX !== undefined) ? camera.rotationX : 0;
      this.rotationY = (camera?.rotationY !== undefined) ? camera.rotationY : 0;
      this.updateWorldMatrix();
      this.fov = (camera?.fov !== undefined) ? camera.fov : 70;
      this.userData = (typeof camera?.userData === 'object') ? camera.userData : null;
      this.init = null;
      if (typeof camera?.init === 'function') {
        this.init = camera.init;
      } else if (typeof camera?.init === 'string') {
        try {
          this.init = new Function('html3d', 'camera', camera.init);
        } catch (e) {
          this.init = null;
          console.error(e);
        }
      }
      if (this.init !== null) {
        this.init(this.html3d, this);
        this.updateWorldMatrix();
      }
      this.animate = null;
      if (typeof camera?.animate === 'function') {
        this.animate = camera.animate;
      } else if (typeof camera?.animate === 'string') {
        try {
          this.animate = new Function('html3d', 'camera', camera.animate);
        } catch (e) {
          this.animate = null;
          console.error(e);
        }
      }
    }
    updateWorldMatrix() {
      this.worldMatrix.setTranslate(this.x, this.y, this.z);
      this.worldMatrix.multiply(new HTML3D.Matrix4().setRotateY(this.rotationY));
      this.worldMatrix.multiply(new HTML3D.Matrix4().setRotateX(this.rotationX));
    }
    render() {
      this.viewMatrix.setMatrix(this.worldMatrix).invert();
    }
  };
  HTML3D.Panel = class Panel {
    constructor(html3d, scenePanel) {
      this.html3d = html3d;
      Object.assign(this, {
        id: ((typeof scenePanel.id === 'string') ? scenePanel.id : null),
        relativeToId: ((typeof scenePanel.relativeToId === 'string') ? scenePanel.relativeToId : null),
        title: ((typeof scenePanel.title === 'string') ? scenePanel.title : null),
        width: ((typeof scenePanel.width === 'number') ? scenePanel.width : 100),
        height: ((typeof scenePanel.height === 'number') ? scenePanel.height : 100),
        anchorCenter: ((typeof scenePanel.anchorCenter === 'boolean') ? scenePanel.anchorCenter : false),
        x: ((typeof scenePanel.x === 'number') ? scenePanel.x : 0),
        y: ((typeof scenePanel.y === 'number') ? scenePanel.y : 0),
        z: ((typeof scenePanel.z === 'number') ? scenePanel.z : 0),
        rotationX: ((typeof scenePanel.rotationX === 'number') ? scenePanel.rotationX : 0),
        rotationY: ((typeof scenePanel.rotationY === 'number') ? scenePanel.rotationY : 0),
        backgroundColor: ((typeof scenePanel.backgroundColor === 'string') ? scenePanel.backgroundColor : 'transparent'),
        backgroundImage: ((typeof scenePanel.backgroundImage === 'string') ? scenePanel.backgroundImage : null),
        backgroundTileImage: ((typeof scenePanel.backgroundTileImage === 'string') ? scenePanel.backgroundTileImage : null),
        opacity: ((typeof scenePanel.opacity === 'number') ? scenePanel.opacity : null),
        obstruction: ((typeof scenePanel.obstruction === 'boolean') ? scenePanel.obstruction : false),
        interaction: ((typeof scenePanel.interaction === 'boolean') ? scenePanel.interaction : false),
        innerHTML: ((typeof scenePanel.innerHTML === 'string') ? scenePanel.innerHTML : null),
        iframeSrc: ((typeof scenePanel.iframeSrc === 'string') ? scenePanel.iframeSrc : null),
        iframeHtml: ((typeof scenePanel.iframeHtml === 'string') ? scenePanel.iframeHtml : null),
        userData: ((typeof scenePanel.userData === 'object') ? scenePanel.userData : null),
        init: null,
        click: null,
        animate: null
      });
      if (typeof scenePanel.init === 'function') {
        this.init = scenePanel.init;
      } else if (typeof scenePanel.init === 'string') {
        try {
          this.init = new Function('html3d', 'panel', scenePanel.init);
        } catch (e) {
          this.init = null;
        }
      }
      if (typeof scenePanel.click === 'function') {
        this.click = scenePanel.click;
      } else if (typeof scenePanel.click === 'string') {
        try {
          this.click = new Function('html3d', 'panel', scenePanel.click);
        } catch (e) {
          this.click = null;
          console.error(e);
        }
      }
      if (typeof scenePanel.animate === 'function') {
        this.animate = scenePanel.animate;
      } else if (typeof scenePanel.animate === 'string') {
        try {
          this.animate = new Function('html3d', 'panel', scenePanel.animate);
        } catch (e) {
          this.animate = null;
          console.error(e);
        }
      }
      this.iframe = null;
      this.element = document.createElement('div');
      if (this.id !== null) {
        this.element.id = this.id;
      }
      if (this.title !== null) {
        this.element.title = this.title;
      }
      Object.assign(this.element.style, {
        position: 'absolute',
        width: this.width + 'px',
        height: this.height + 'px',
        backgroundColor: this.backgroundColor,
        pointerEvents: (((this.interaction === true) || (this.obstruction === true)) ? 'auto' : 'none'),
        userSelect: ((this.interaction === true) ? 'auto' : 'none')
      });
      html3d.sceneContainer.appendChild(this.element);
      if (this.innerHTML !== null) {
        this.element.innerHTML = this.innerHTML;
      } else if ((this.iframeSrc !== null) || (this.iframeHtml !== null)) {
        this.element.style.width = (this.width - 10) + 'px';
        this.element.style.height = (this.height - 10) + 'px';
        this.element.style.border = '5px solid ' + this.backgroundColor;
        this.iframe = document.createElement('iframe');
        this.iframe.setAttribute('referrerpolicy', 'strict-origin-when-cross-origin');
        if (this.iframeSrc !== null) {
          this.iframe.src = this.iframeSrc;
        } else if (this.iframeHtml !== null) {
          this.iframe.srcdoc = this.iframeHtml;
        }
        Object.assign(this.iframe.style, {
          position: 'absolute',
          left: '0px',
          top: '0px',
          width: (this.width - 10) + 'px',
          height: (this.height - 10) + 'px',
          border: 'none'
        });
        this.element.appendChild(this.iframe);
      } else if (this.backgroundImage !== null) {
        this.element.style.backgroundImage = this.backgroundImage;
        this.element.style.backgroundSize = 'contain';
        this.element.style.backgroundPosition = 'center';
        this.element.style.backgroundRepeat = 'no-repeat';
      } else if (this.backgroundTileImage !== null) {
        this.element.style.backgroundImage = this.backgroundTileImage;
        this.element.style.backgroundRepeat = 'repeat';
      }
      if (this.opacity !== null) {
        this.element.style.opacity = this.opacity;
      }
      if (this.click !== null) {
        this.element.style.cursor = 'pointer';
        this.element.addEventListener('click', (event) => {
          event.stopPropagation();
          this.click(html3d, this);
        });
      }
      this.worldMatrix = new HTML3D.Matrix4();
      this.boundingBox = null;
      this.updateWorldMatrix();
    }
    export() {
      const result = {
        id: (this.id !== null) ? this.id : undefined,
        relativeToId: (this.relativeToId !== null) ? this.relativeToId : undefined,
        title: (this.title !== null) ? this.title : undefined,
        width: this.width,
        height: this.height,
        anchorCenter: (this.anchorCenter === true) ? this.anchorCenter : undefined,
        x: this.x,
        y: this.y,
        z: this.z,
        rotationX: (this.rotationX !== 0) ? this.rotationX : undefined,
        rotationY: (this.rotationY !== 0) ? this.rotationY : undefined,
        backgroundColor: this.backgroundColor,
        backgroundImage: (this.backgroundImage !== null) ? this.backgroundImage : undefined,
        backgroundTileImage: (this.backgroundTileImage !== null) ? this.backgroundTileImage : undefined,
        opacity: (this.opacity !== null) ? this.opacity : undefined,
        obstruction: (this.obstruction !== null) ? this.obstruction : undefined,
        interaction: (this.interaction !== null) ? this.interaction : undefined,
        innerHTML: (this.innerHTML !== null) ? this.innerHTML.trim() : undefined,
        iframeSrc: (this.iframeSrc !== null) ? this.iframeSrc : undefined,
        iframeHtml: (this.iframeHtml !== null) ? this.iframeHtml : undefined
      };
      if ((typeof this.userData === 'object') && (this.userData !== null)) {
        result.userData = {...this.userData};
      }
      if (typeof this.init === 'function') {
        result.init = this.init.toString();
        result.init = result.init.substring(result.init.indexOf('{') + 1, result.init.lastIndexOf('}')).trim();
      }
      if (typeof this.click === 'function') {
        result.click = this.click.toString();
        result.click = result.click.substring(result.click.indexOf('{') + 1, result.click.lastIndexOf('}')).trim();
      }
      if (typeof this.animate === 'function') {
        result.animate = this.animate.toString();
        result.animate = result.animate.substring(result.animate.indexOf('{') + 1, result.animate.lastIndexOf('}')).trim();
      }
      return result;
    }
    updateWorldMatrix() {
      this.worldMatrix.reset();
      if (this.relativeToId !== null) {
        const relativeToPanel = this.html3d.panels.find((panel) => (panel.id === this.relativeToId));
        if (relativeToPanel) {
          this.worldMatrix.setMatrix(relativeToPanel.worldMatrix);
        }
      }
      this.worldMatrix.multiply(new HTML3D.Matrix4().setTranslate(this.x, this.y, this.z)).multiply(new HTML3D.Matrix4().setRotateY(this.rotationY)).multiply(new HTML3D.Matrix4().setRotateX(this.rotationX));
      if (this.obstruction === true) {
        const eitherSide = 10;
        if (this.anchorCenter === true) {
          this.boundingBox = new HTML3D.BoundingBox(
            new HTML3D.Vector3(-this.width / 2, -this.height / 2, -eitherSide),
            new HTML3D.Vector3(this.width / 2, this.height / 2, eitherSide)
          );
        } else {
          this.boundingBox = new HTML3D.BoundingBox(
            new HTML3D.Vector3(0, 0, -eitherSide),
            new HTML3D.Vector3(this.width, this.height, eitherSide)
          );
        }
        this.boundingBox.applyMatrix4(this.worldMatrix);
      } else {
        this.boundingBox = null;
      }
      for (const panel of this.html3d.panels) {
        if (panel.relativeToId === this.id) {
          panel.updateWorldMatrix();
        }
      }
    }
    render() {
      this.element.style.transform = `translate(-50%, -50%) ${this.worldMatrix.toCSSMatrixString()}${this.anchorCenter ? '' : ' translate(50%, 50%)'}`;
    }
  }
  HTML3D.Vector3 = class Vector3 {
    constructor(x = 0, y = 0, z = 0) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    set(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
    clone() {
      return new HTML3D.Vector3(this.x, this.y, this.z);
    }
    add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    multiplyScalar(s) {
      this.x *= s;
      this.y *= s;
      this.z *= s;
      return this;
    }
    lengthSq() {
      return (this.x * this.x) + (this.y * this.y) + (this.z * this.z);
    }
    length() {
      return Math.sqrt(this.lengthSq());
    }
    normalize() {
      const l = this.length();
      if (l > 0.00001) {
        this.multiplyScalar(1 / l);
      }
      return this;
    }
    applyMatrix4(m) {
      const x = this.x;
      const y = this.y;
      const z = this.z;
      const e = m.elements;
      const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    applyMatrix4Rotation(m) {
      const x = this.x;
      const y = this.y;
      const z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
    dot(v) {
      return (this.x * v.x) + (this.y * v.y) + (this.z * v.z);
    }
  }
  HTML3D.Matrix4 = class Matrix4 {
    constructor() {
      this.reset();
    }
    reset() {
      this.elements = [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
      ];
      return this;
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      const te = this.elements;
      te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
      te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
      te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
      te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;
      return this;
    }
    setMatrix(m) {
      this.elements = [...m.elements];
      return this;
    }
    clone() {
      const newMatrix = new HTML3D.Matrix4();
      newMatrix.elements = [...this.elements];
      return newMatrix;
    }
    setTranslate(x, y, z) {
      return this.set(
        1, 0, 0, x,
        0, 1, 0, y,
        0, 0, 1, z,
        0, 0, 0, 1
      );
    }
    setRotateX(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      return this.set(
        1, 0, 0, 0,
        0, c, -s, 0,
        0, s, c, 0,
        0, 0, 0, 1
      );
    }
    setRotateY(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      return this.set(
        c, 0, s, 0,
        0, 1, 0, 0,
        -s, 0, c, 0,
        0, 0, 0, 1
      );
    }
    multiply(m) {
      const me = m.elements;
      const te = this.elements;
      const a11 = te[0], a12 = te[4], a13 = te[8], a14 = te[12];
      const a21 = te[1], a22 = te[5], a23 = te[9], a24 = te[13];
      const a31 = te[2], a32 = te[6], a33 = te[10], a34 = te[14];
      const a41 = te[3], a42 = te[7], a43 = te[11], a44 = te[15];
      const b11 = me[0], b12 = me[4], b13 = me[8], b14 = me[12];
      const b21 = me[1], b22 = me[5], b23 = me[9], b24 = me[13];
      const b31 = me[2], b32 = me[6], b33 = me[10], b34 = me[14];
      const b41 = me[3], b42 = me[7], b43 = me[11], b44 = me[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
    invert() {
      const te = this.elements;
      const r11 = te[0], r12 = te[4], r13 = te[8];
      const r21 = te[1], r22 = te[5], r23 = te[9];
      const r31 = te[2], r32 = te[6], r33 = te[10];
      const tx = te[12], ty = te[13], tz = te[14];
      te[0] = r11; te[4] = r21; te[8] = r31;
      te[1] = r12; te[5] = r22; te[9] = r32;
      te[2] = r13; te[6] = r23; te[10] = r33;
      te[12] = -(te[0] * tx + te[4] * ty + te[8] * tz);
      te[13] = -(te[1] * tx + te[5] * ty + te[9] * tz);
      te[14] = -(te[2] * tx + te[6] * ty + te[10] * tz);
      return this;
    }
    toCSSMatrixString() {
      return `matrix3d(${this.elements.join(',')})`;
    }
  }
  HTML3D.BoundingBox = class BoundingBox {
    constructor(min = new HTML3D.Vector3(+Infinity, +Infinity, +Infinity), max = new HTML3D.Vector3(-Infinity, -Infinity, -Infinity)) {
      this.min = min;
      this.max = max;
    }
    applyMatrix4(matrix) {
      const points = [
        new HTML3D.Vector3(this.min.x, this.min.y, this.min.z),
        new HTML3D.Vector3(this.min.x, this.min.y, this.max.z),
        new HTML3D.Vector3(this.min.x, this.max.y, this.min.z),
        new HTML3D.Vector3(this.min.x, this.max.y, this.max.z),
        new HTML3D.Vector3(this.max.x, this.min.y, this.min.z),
        new HTML3D.Vector3(this.max.x, this.min.y, this.max.z),
        new HTML3D.Vector3(this.max.x, this.max.y, this.min.z),
        new HTML3D.Vector3(this.max.x, this.max.y, this.max.z),
      ];
      this.min.set(+Infinity, +Infinity, +Infinity);
      this.max.set(-Infinity, -Infinity, -Infinity);
      for (let i = 0; i < 8; i++) {
        points[i].applyMatrix4(matrix);
        this.min.x = Math.min(this.min.x, points[i].x);
        this.min.y = Math.min(this.min.y, points[i].y);
        this.min.z = Math.min(this.min.z, points[i].z);
        this.max.x = Math.max(this.max.x, points[i].x);
        this.max.y = Math.max(this.max.y, points[i].y);
        this.max.z = Math.max(this.max.z, points[i].z);
      }
      return this;
    }
    intersectsBox(box) {
      return ((this.max.x >= box.min.x) && (this.min.x <= box.max.x) && (this.max.y >= box.min.y) && (this.min.y <= box.max.y) && (this.max.z >= box.min.z) && (this.min.z <= box.max.z));
    }
  }
}

const volumetricWidth = 2000;
const volumetricDepth = 1000;
const volumetricHeight = 1000;
const baseHeight = 300;
const SCENE = {
  camera: {
    x: 0,
    y: 0,
    z: 5000,
    rotationX: 0,
    rotationY: 0,
    fov: 70,
    init(html3d, camera) {
      camera.isDragging = false;
      camera.radius = 1500;
      camera.rotationX = 0;
      camera.rotationY = 0;
      camera.calcXyz = () => {
        camera.x = camera.radius * Math.cos(camera.rotationX) * Math.cos((Math.PI / 2) - camera.rotationY);
        camera.z = camera.radius * Math.cos(camera.rotationX) * Math.sin((Math.PI / 2) - camera.rotationY);
        camera.y = camera.radius * Math.sin(-camera.rotationX);
      };
      camera.calcXyz();
      camera.requestRender = true;
      let previousX = 0;
      let previousY = 0;
      document.addEventListener('pointerdown', (event) => {
        camera.isDragging = true;
        previousX = event.clientX;
        previousY = event.clientY;
      });
      document.addEventListener('pointermove', (event) => {
        if (camera.isDragging) {
          event.preventDefault();
          const deltaX = event.clientX - previousX;
          const deltaY = event.clientY - previousY;
          previousX = event.clientX;
          previousY = event.clientY;
          camera.rotationX += deltaY * 0.005;
          if (camera.rotationX > (Math.PI / 2)) {
            camera.rotationX = Math.PI / 2;
          }
          if (camera.rotationX < -(Math.PI / 15)) {
            camera.rotationX = -(Math.PI / 15);
          }
          camera.rotationY -= deltaX * 0.003;
          camera.calcXyz();
          camera.requestRender = true;
        }
      });
      document.addEventListener('pointerup', () => {
        camera.isDragging = false;
      });
      document.addEventListener('wheel', (event) => {
        event.preventDefault();
        camera.radius += event.deltaY * 1;
        if (camera.radius < 300) {
          camera.radius = 300;
        }
        if (camera.radius > 5000) {
          camera.radius = 5000;
        }
        camera.calcXyz();
        camera.requestRender = true;
      }, { passive: false });
    },
    animate(html3d, camera) {
      if (camera.requestRender) {
        camera.requestRender = false;
        camera.updateWorldMatrix();
        html3d.requestRender = true;
      }
    }
  },
  panels: [
    {
      id: 'volumetricDisplayFront',
      width: volumetricWidth,
      height: baseHeight,
      x: -(volumetricWidth / 2), 
      y: ((volumetricHeight / 2) / 2),
      z: (volumetricDepth / 2),
      rotationX: 0,
      rotationY: 0,
      backgroundColor: '#222222',
      interaction: true,
      innerHTML: `
        <div style="position: absolute; left: 40px; top: 30px; width: 600px; height: 200px; background-color: transparent; user-select: none;">
          <div style="position: absolute; left: 0px; top: 0px; width: 600px; height: 40px; line-height: 40px; background-color: transparent; color: #ffffff; font-family: Arial, sans-serif; font-size: 28px;">
            Cubic Voxel Volumetric Display
          </div>
          <div id="volumetricDisplay_plate" style="position: absolute; left: 0px; top: 60px; width: 300px; height: 60px; background-color: transparent; color: #ffffDD; font-family: Arial, sans-serif; font-size: 16px;">
          </div>
        </div>
        <div id="volumetricDisplay_ui" style="position: absolute; left: 1200px; top: 40px; width: 640px; height: 210px; border-radius: 5px; background-color: #000000; overflow: hidden; user-select: none;">
        </div>
        <div id="volumetricDisplay_onOffButton" title="On / Standby" style="position: absolute; left: 1890px; top: 50px; width: 60px; height: 60px; border: 5px solid #FFDF00; border-radius: 60px; background-color: transparent; color: #ffffff; text-align: center; box-shadow: 0 0 15px #F77C00; cursor: pointer;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="position: absolute; left: 10px; top: 10px; width: 40px; height: 40px;" fill="#ffffff" stroke="none">
            <path d="M16.56,5.44L15.11,6.89C16.84,7.94 18,9.83 18,12A6,6 0 0,1 12,18A6,6 0 0,1 6,12C6,9.83 7.16,7.94 8.88,6.88L7.44,5.44C5.36,6.88 4,9.28 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12C20,9.28 18.64,6.88 16.56,5.44M13,3H11V13H13"></path>
          </svg>
        </div>
      `,
      init(html3d, panel) {
        panel.instanceData = {
          plate: null,
          ui: null,
          onOffButton: null
        };
        panel.instanceData.plate = panel.element.querySelector('#volumetricDisplay_plate');
        const numberOfPixels = ((VolumetricDisplay.numberOfLayersX * (VolumetricDisplay.numberOfLayersY - 1) * (VolumetricDisplay.numberOfLayersZ - 1)) + (VolumetricDisplay.numberOfLayersY * (VolumetricDisplay.numberOfLayersX - 1) * (VolumetricDisplay.numberOfLayersZ - 1)) + (VolumetricDisplay.numberOfLayersZ * (VolumetricDisplay.numberOfLayersX - 1) * (VolumetricDisplay.numberOfLayersY - 1)));
        const numberOfVoxels = ((VolumetricDisplay.numberOfLayersX - 1) * (VolumetricDisplay.numberOfLayersY - 1) * (VolumetricDisplay.numberOfLayersZ - 1));
        panel.instanceData.plate.innerHTML = `
          ${numberOfPixels} pixels<br />
          ${numberOfVoxels} voxels
        `;
        panel.instanceData.ui = panel.element.querySelector('#volumetricDisplay_ui');
        panel.instanceData.button = panel.element.querySelector('#volumetricDisplay_onOffButton');
        panel.instanceData.button.addEventListener('click', (event) => {
          event.stopPropagation();
          VolumetricDisplayControl.setIsOn(!VolumetricDisplayControl.getIsOn());
          if (VolumetricDisplayControl.getIsOn()) {
            panel.instanceData.button.style.border = '5px solid #55F755';
            panel.instanceData.button.style.boxShadow = '0 0 15px #00F700';
            html3d.panels.find((p) => (p.id === 'volumetricDisplayBottom')).element.style.boxShadow = '0 0 40px 2px #EEEEEE80';
          } else {
            panel.instanceData.button.style.border = '5px solid #FFDF00';
            panel.instanceData.button.style.boxShadow = '0 0 15px #F77C00';
            html3d.panels.find((p) => (p.id === 'volumetricDisplayBottom')).element.style.boxShadow = '0 0 40px 2px #11111180';
          }
        });
      }
    },
    {
      id: 'volumetricDisplayBase',
      relativeToId: 'volumetricDisplayFront',
      width: volumetricWidth,
      height: volumetricDepth,
      x: 0,
      y: 1,
      z: -volumetricDepth,
      rotationX: Math.PI / 2,
      rotationY: 0,
      backgroundColor: '#000000'
    },
    {
      id: 'volumetricDisplayBottom',
      relativeToId: 'volumetricDisplayFront',
      width: volumetricWidth,
      height: volumetricDepth,
      x: 0,
      y: baseHeight,
      z: -volumetricDepth,
      rotationX: Math.PI / 2,
      rotationY: 0,
      backgroundColor: '#000000',
      init(html3d, panel) {
        panel.element.style.boxShadow = '0 0 40px 2px #111111';
      }
    },
    {
      id: 'volumetricDisplayBack',
      relativeToId: 'volumetricDisplayFront',
      width: volumetricWidth,
      height: baseHeight,
      x: 0,
      y: 0,
      z: -volumetricDepth,
      rotationX: 0,
      rotationY: 0,
      backgroundColor: '#222222'
    },
    {
      id: 'volumetricDisplayLeft',
      relativeToId: 'volumetricDisplayFront',
      width: volumetricDepth,
      height: baseHeight,
      x: 0,
      y: 0,
      z: -volumetricDepth,
      rotationX: 0,
      rotationY: -Math.PI / 2,
      backgroundColor: '#111111'
    },
    {
      id: 'volumetricDisplayRight',
      relativeToId: 'volumetricDisplayFront',
      width: volumetricDepth,
      height: baseHeight,
      x: volumetricWidth, 
      y: 0,
      z: 0,
      rotationX: 0,
      rotationY: Math.PI / 2,
      backgroundColor: '#111111'
    }
  ]
};

const VolumetricDisplay = {
  numberOfLayersX: 41,
  numberOfLayersY: 21,
  numberOfLayersZ: 21,
  layersX: [],
  layersY: [],
  layersZ: [],
  panelsXYZ: [],
  init() {
    for (let i = 0; i < this.numberOfLayersX; i++) {
      const layer = {
        rows: []
      };
      for (let j = 0; j < this.numberOfLayersY; j++) {
        const row = {
          squares: []
        };
        for (let k = 0; k < this.numberOfLayersZ; k++) {
          const square = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
          };
          row.squares.push(square);
        }
        layer.rows.push(row);
      }
      this.layersX.push(layer);
    }
    for (let i = 0; i < this.numberOfLayersY; i++) {
      const layer = {
        rows: []
      };
      for (let j = 0; j < this.numberOfLayersZ; j++) {
        const row = {
          squares: []
        };
        for (let k = 0; k < this.numberOfLayersX; k++) {
          const square = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
          };
          row.squares.push(square);
        }
        layer.rows.push(row);
      }
      this.layersY.push(layer);
    }
    for (let i = 0; i < this.numberOfLayersZ; i++) {
      const layer = {
        rows: []
      };
      for (let j = 0; j < this.numberOfLayersY; j++) {
        const row = {
          squares: []
        };
        for (let k = 0; k < this.numberOfLayersX; k++) {
          const square = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
          };
          row.squares.push(square);
        }
        layer.rows.push(row);
      }
      this.layersZ.push(layer);
    }
    const layerSpacingX = volumetricWidth / (this.layersX.length - 1);
    const layerSpacingY = volumetricHeight / (this.layersY.length - 1);
    const layerSpacingZ = volumetricDepth / (this.layersZ.length - 1);
    for (let i = 0, ic = this.layersX.length; i < ic; i++) {
      const panel = {
        id: `layerX${i}`,
        relativeToId: 'volumetricDisplayFront',
        width: volumetricDepth,
        height: volumetricHeight,
        x: (i * layerSpacingX),
        y: -volumetricHeight,
        z: 0,
        rotationX: 0,
        rotationY: Math.PI / 2,
        backgroundColor: 'transparent',
        innerHTML: `
          <canvas id="layerXcanvas${i}" width="${(this.layersZ.length - 1)}" height="${(this.layersY.length - 1)}" style="position: absolute; left: 0px; top: 0px; border: 0px; margin: 0px; padding: 0px; width: ${volumetricDepth}px; height: ${volumetricHeight}px; image-rendering: pixelated;">
          </canvas>
        `,
        userData: {
          layerIndex: i
        },
        init(html3d, panel) {
          panel.instanceData = {};
          panel.instanceData.requestLayerUpdate = false;
          panel.instanceData.canvas = panel.element.querySelector(`#layerXcanvas${panel.userData.layerIndex}`);
          panel.instanceData.context = panel.instanceData.canvas.getContext('2d');
          panel.instanceData.image = panel.instanceData.context.createImageData(VolumetricDisplay.layersZ.length, VolumetricDisplay.layersY.length);
          const image = panel.instanceData.image;
          const layer = VolumetricDisplay.layersX[panel.userData.layerIndex];
          for (let i = 0, ic = layer.rows.length; i < ic; i++) {
            const row = layer.rows[i];
            for (let j = 0, jc = row.squares.length; j < jc; j++) {
              const index = ((i * row.squares.length) + j) * 4;
              const square = row.squares[j];
              image.data[index + 0] = square.r;
              image.data[index + 1] = square.g;
              image.data[index + 2] = square.b;
              image.data[index + 3] = square.a;
            }
          }
          panel.instanceData.context.putImageData(panel.instanceData.image, 0, 0);
          VolumetricDisplay.panelsXYZ.push(panel);
        },
        animate(html3d, panel) {
          if (panel.instanceData.requestLayerUpdate) {
            panel.instanceData.requestLayerUpdate = false;
            const image = panel.instanceData.image;
            const layer = VolumetricDisplay.layersX[panel.userData.layerIndex];
            for (let i = 0, ic = layer.rows.length; i < ic; i++) {
              const row = layer.rows[i];
              for (let j = 0, jc = row.squares.length; j < jc; j++) {
                const index = ((i * row.squares.length) + j) * 4;
                const square = row.squares[j];
                image.data[index + 0] = square.r;
                image.data[index + 1] = square.g;
                image.data[index + 2] = square.b;
                image.data[index + 3] = square.a;
              }
            }
            panel.instanceData.context.putImageData(panel.instanceData.image, 0, 0);
          }
        }
      };
      SCENE.panels.push(panel);
    }
    for (let i = 0, ic = this.layersY.length; i < ic; i++) {
      const panel = {
        id: `layerY${i}`,
        relativeToId: 'volumetricDisplayFront',
        width: volumetricWidth,
        height: volumetricDepth,
        x: 0,
        y: -volumetricHeight + (i * layerSpacingY),
        z: 0,
        rotationX: -Math.PI / 2,
        rotationY: 0,
        backgroundColor: 'transparent',
        innerHTML: `
          <canvas id="layerYcanvas${i}" width="${(this.layersX.length - 1)}" height="${(this.layersZ.length - 1)}" style="position: absolute; left: 0px; top: 0px; border: 0px; margin: 0px; padding: 0px; width: ${volumetricWidth}px; height: ${volumetricDepth}px; image-rendering: pixelated;">
          </canvas>
        `,
        userData: {
          layerIndex: i
        },
        init(html3d, panel) {
          panel.instanceData = {};
          panel.instanceData.requestLayerUpdate = false;
          panel.instanceData.canvas = panel.element.querySelector(`#layerYcanvas${panel.userData.layerIndex}`);
          panel.instanceData.context = panel.instanceData.canvas.getContext('2d');
          panel.instanceData.image = panel.instanceData.context.createImageData(VolumetricDisplay.layersX.length, VolumetricDisplay.layersZ.length);
          const image = panel.instanceData.image;
          const layer = VolumetricDisplay.layersY[panel.userData.layerIndex];
          for (let i = 0, ic = layer.rows.length; i < ic; i++) {
            const row = layer.rows[i];
            for (let j = 0, jc = row.squares.length; j < jc; j++) {
              const index = ((i * row.squares.length) + j) * 4;
              const square = row.squares[j];
              image.data[index + 0] = square.r;
              image.data[index + 1] = square.g;
              image.data[index + 2] = square.b;
              image.data[index + 3] = square.a;
            }
          }
          panel.instanceData.context.putImageData(panel.instanceData.image, 0, 0);
          VolumetricDisplay.panelsXYZ.push(panel);
        },
        animate(html3d, panel) {
          if (panel.instanceData.requestLayerUpdate) {
            panel.instanceData.requestLayerUpdate = false;
            const image = panel.instanceData.image;
            const layer = VolumetricDisplay.layersY[panel.userData.layerIndex];
            for (let i = 0, ic = layer.rows.length; i < ic; i++) {
              const row = layer.rows[i];
              for (let j = 0, jc = row.squares.length; j < jc; j++) {
                const index = ((i * row.squares.length) + j) * 4;
                const square = row.squares[j];
                image.data[index + 0] = square.r;
                image.data[index + 1] = square.g;
                image.data[index + 2] = square.b;
                image.data[index + 3] = square.a;
              }
            }
            panel.instanceData.context.putImageData(panel.instanceData.image, 0, 0);
          }
        }
      };
      SCENE.panels.push(panel);
    }
    for (let i = 0, ic = this.layersZ.length; i < ic; i++) {
      const panel = {
        id: `layerZ${i}`,
        relativeToId: 'volumetricDisplayFront',
        width: volumetricWidth,
        height: volumetricHeight,
        x: 0,
        y: -volumetricHeight,
        z: -(i * layerSpacingZ),
        rotationX: 0,
        rotationY: 0,
        backgroundColor: 'transparent',
        innerHTML: `
          <canvas id="layerZcanvas${i}" width="${(this.layersX.length - 1)}" height="${(this.layersY.length - 1)}" style="position: absolute; left: 0px; top: 0px; border: 0px; margin: 0px; padding: 0px; width: ${volumetricWidth}px; height: ${volumetricHeight}px; image-rendering: pixelated;">
          </canvas>
        `,
        userData: {
          layerIndex: i
        },
        init(html3d, panel) {
          panel.instanceData = {};
          panel.instanceData.requestLayerUpdate = false;
          panel.instanceData.canvas = panel.element.querySelector(`#layerZcanvas${panel.userData.layerIndex}`);
          panel.instanceData.context = panel.instanceData.canvas.getContext('2d');
          panel.instanceData.image = panel.instanceData.context.createImageData(VolumetricDisplay.layersX.length, VolumetricDisplay.layersY.length);
          const image = panel.instanceData.image;
          const layer = VolumetricDisplay.layersZ[panel.userData.layerIndex];
          for (let i = 0, ic = layer.rows.length; i < ic; i++) {
            const row = layer.rows[i];
            for (let j = 0, jc = row.squares.length; j < jc; j++) {
              const index = ((i * row.squares.length) + j) * 4;
              const square = row.squares[j];
              image.data[index + 0] = square.r;
              image.data[index + 1] = square.g;
              image.data[index + 2] = square.b;
              image.data[index + 3] = square.a;
            }
          }
          panel.instanceData.context.putImageData(panel.instanceData.image, 0, 0);
          VolumetricDisplay.panelsXYZ.push(panel);
        },
        animate(html3d, panel) {
          if (panel.instanceData.requestLayerUpdate) {
            panel.instanceData.requestLayerUpdate = false;
            const image = panel.instanceData.image;
            const layer = VolumetricDisplay.layersZ[panel.userData.layerIndex];
            for (let i = 0, ic = layer.rows.length; i < ic; i++) {
              const row = layer.rows[i];
              for (let j = 0, jc = row.squares.length; j < jc; j++) {
                const index = ((i * row.squares.length) + j) * 4;
                const square = row.squares[j];
                image.data[index + 0] = square.r;
                image.data[index + 1] = square.g;
                image.data[index + 2] = square.b;
                image.data[index + 3] = square.a;
              }
            }
            panel.instanceData.context.putImageData(panel.instanceData.image, 0, 0);
          }
        }
      };
      SCENE.panels.push(panel);
    }
  },
  update() {
    for (let i = 0, ic = this.panelsXYZ.length; i < ic; i++) {
      const panel = this.panelsXYZ[i];
      if (panel.instanceData) {
        panel.instanceData.requestLayerUpdate = true;
      }
    }
  },
  fill(color) {
    const r = color?.r || 0;
    const g = color?.g || 0;
    const b = color?.b || 0;
    const a = color?.a || 0;
    for (let i = 0, ic = this.layersX.length; i < ic; i++) {
      const layer = this.layersX[i];
      for (let j = 0, jc = layer.rows.length; j < jc; j++) {
        const row = layer.rows[j];
        for (let k = 0, kc = row.squares.length; k < kc; k++) {
          const square = row.squares[k];
          square.r = r;
          square.g = g;
          square.b = b;
          square.a = a;
        }
      }
    }
    for (let i = 0, ic = this.layersY.length; i < ic; i++) {
      const layer = this.layersY[i];
      for (let j = 0, jc = layer.rows.length; j < jc; j++) {
        const row = layer.rows[j];
        for (let k = 0, kc = row.squares.length; k < kc; k++) {
          const square = row.squares[k];
          square.r = r;
          square.g = g;
          square.b = b;
          square.a = a;
        }
      }
    }
    for (let i = 0, ic = this.layersZ.length; i < ic; i++) {
      const layer = this.layersZ[i];
      for (let j = 0, jc = layer.rows.length; j < jc; j++) {
        const row = layer.rows[j];
        for (let k = 0, kc = row.squares.length; k < kc; k++) {
          const square = row.squares[k];
          square.r = r;
          square.g = g;
          square.b = b;
          square.a = a;
        }
      }
    }
  },
  fillVoxel(voxel) {
    if (voxel.a > 0) {
      if ((voxel.x >= 0) && (voxel.x < (this.layersX.length - 1)) && (voxel.y >= 0) && (voxel.y < (this.layersY.length - 1)) && (voxel.z >= 0) && (voxel.z < (this.layersZ.length - 1))) {
        const squareX = this.layersX[voxel.x].rows[voxel.y].squares[voxel.z];
        if (voxel.a > squareX.a) {
          squareX.r = (voxel.r * 0.85) | 0;
          squareX.g = (voxel.g * 0.85) | 0;
          squareX.b = (voxel.b * 0.85) | 0;
          squareX.a = voxel.a;
        }
        const squareY = this.layersY[voxel.y].rows[voxel.z].squares[voxel.x];
        if (voxel.a > squareY.a) {
          squareY.r = (voxel.r * 0.92) | 0;
          squareY.g = (voxel.g * 0.92) | 0;
          squareY.b = (voxel.b * 0.92) | 0;
          squareY.a = voxel.a;
        }
        const squareZ = this.layersZ[voxel.z].rows[voxel.y].squares[voxel.x];
        if (voxel.a > squareZ.a) {
          squareZ.r = voxel.r;
          squareZ.g = voxel.g;
          squareZ.b = voxel.b;
          squareZ.a = voxel.a;
        }
        const squareX1 = this.layersX[voxel.x + 1].rows[voxel.y].squares[voxel.z];
        if (voxel.a > squareX1.a) {
          squareX1.r = (voxel.r * 0.85) | 0;
          squareX1.g = (voxel.g * 0.85) | 0;
          squareX1.b = (voxel.b * 0.85) | 0;
          squareX1.a = voxel.a;
        }
        const squareY1 = this.layersY[voxel.y + 1].rows[voxel.z].squares[voxel.x];
        if (voxel.a > squareY1.a) {
          squareY1.r = (voxel.r * 0.92) | 0;
          squareY1.g = (voxel.g * 0.92) | 0;
          squareY1.b = (voxel.b * 0.92) | 0;
          squareY1.a = voxel.a;
        }
        const squareZ1 = this.layersZ[voxel.z + 1].rows[voxel.y].squares[voxel.x];
        if (voxel.a > squareZ1.a) {
          squareZ1.r = voxel.r;
          squareZ1.g = voxel.g;
          squareZ1.b = voxel.b;
          squareZ1.a = voxel.a;
        }
      }
    }
  }
};
VolumetricDisplay.init();

const VolumetricDisplayControl = {
  isOn: false,
  programIndex: 0,
  ui: null,
  uiDisplay: null,
  uiDisplayLeftPanel: null,
  uiDisplayLeftPanelHeader: null,
  uiDisplayRightPanel: null,
  uiDisplayRightPanelHeader: null,
  uiDisplayRightPanelBody: null,
  uiDisplayWidth: 640,
  uiDisplayHeight: 210,
  uiDisplayLeftPanelWidth: 300,
  uiDisplayRightPanelWidth: 318,
  init() {
    setTimeout(() => {
      this.ui = window.html3dInstance.panels.find((p) => (p.id === 'volumetricDisplayFront')).instanceData.ui;
      this.uiDisplay = document.createElement('div');
      Object.assign(this.uiDisplay.style, {
        display: 'none',
        position: 'absolute',
        left: '0px',
        top: '0px',
        width: this.uiDisplayWidth + 'px',
        height: this.uiDisplayHeight + 'px',
        backgroundColor: '#000000',
        color: '#88ffff',
        fontFamily: 'monospace'
      });
      this.ui.appendChild(this.uiDisplay);
      this.uiDisplayLeftPanel = document.createElement('div');
      Object.assign(this.uiDisplayLeftPanel.style, {
        position: 'absolute',
        left: '5px',
        top: '5px',
        width: (this.uiDisplayLeftPanelWidth - 10) + 'px',
        height: (this.uiDisplayHeight - 10) + 'px',
        backgroundColor: '#000000',
        overflowX: 'hidden',
        overflowY: 'auto',
        scrollbarColor: '#008888 #000000',
        fontSize: '16px',
        userSelect: 'none'
      });
      this.uiDisplay.appendChild(this.uiDisplayLeftPanel);
      this.uiDisplayLeftPanelHeader = document.createElement('div');
      Object.assign(this.uiDisplayLeftPanelHeader.style, {
        position: 'absolute',
        left: 5 + 'px',
        top: '0px',
        width: 250 + 'px',
        height: '30px',
        lineHeight: '30px',
        backgroundColor: 'transparent',
        fontSize: '20px',
        userSelect: 'none'
      });
      this.uiDisplayLeftPanel.appendChild(this.uiDisplayLeftPanelHeader);
      this.uiDisplayLeftPanelHeader.innerText = 'Select program';
      for (let i = 0, ic = VolumetricDisplayPrograms.programs.length; i < ic; i++) {
        const program = VolumetricDisplayPrograms.programs[i];
        const programButton = document.createElement('div');
        programButton.id = `programButton${i}`;
        Object.assign(programButton.style, {
          position: 'absolute',
          left: 10 + 'px',
          top: (35 + (i * 32)) + 'px',
          width: 250 + 'px',
          height: 25 + 'px',
          lineHeight: 25 + 'px',
          border: '1px solid #88ffff',
          paddingLeft: '10px',
          backgroundColor: (i === this.programIndex) ? '#88ffff' : 'transparent',
          color: (i === this.programIndex) ? '#000000' : '#88ffff',
          fontSize: '20px',
          userSelect: 'none',
          cursor: 'pointer'
        });
        programButton.innerText = program.name;
        this.uiDisplayLeftPanel.appendChild(programButton);
        programButton.addEventListener('click', (event) => {
          event.stopPropagation();
          if (this.programIndex !== i) {
            const oldProgramButton = this.uiDisplayLeftPanel.querySelector(`#programButton${this.programIndex}`);
            Object.assign(oldProgramButton.style, {
              backgroundColor: 'transparent',
              color: '#88ffff'
            });
            this.programIndex = i;
            Object.assign(programButton.style, {
              backgroundColor: '#88ffff',
              color: '#000000'
            });
            VolumetricDisplay.fill();
            const program = VolumetricDisplayPrograms.programs[this.programIndex];
            this.uiDisplayRightPanelHeader.innerText = program.name;
            this.uiDisplayRightPanelBody.innerHTML = program.uiHtml;
            program.init();
          }
        });
      }
      this.uiDisplayRightPanel = document.createElement('div');
      Object.assign(this.uiDisplayRightPanel.style, {
        position: 'absolute',
        left: (this.uiDisplayLeftPanelWidth + 5) + 'px',
        top: 40 + 'px',
        width: this.uiDisplayRightPanelWidth + 'px',
        height: (this.uiDisplayHeight - 57) + 'px',
        border: '1px solid #88ffff',
        borderRadius: '5px',
        backgroundColor: 'transparent',
        overflow: 'hidden',
        fontSize: '16px',
        color: '#88ffff',
        userSelect: 'none'
      });
      this.uiDisplay.appendChild(this.uiDisplayRightPanel);
      this.uiDisplayRightPanelHeader = document.createElement('div');
      Object.assign(this.uiDisplayRightPanelHeader.style, {
        position: 'absolute',
        left: 0 + 'px',
        top: 0 + 'px',
        width: (this.uiDisplayRightPanelWidth - 10) + 'px',
        height: 25 + 'px',
        paddingLeft: '10px',
        lineHeight: 25 + 'px',
        backgroundColor: '#88ffff',
        color: '#000000',
        fontSize: '20px',
        whiteSpace: 'nowrap',
        overflow: 'hidden',
        userSelect: 'none'
      });
      this.uiDisplayRightPanel.appendChild(this.uiDisplayRightPanelHeader);
      this.uiDisplayRightPanelHeader.innerText = VolumetricDisplayPrograms.programs[this.programIndex].name;
      this.uiDisplayRightPanelBody = document.createElement('div');
      Object.assign(this.uiDisplayRightPanelBody.style, {
        position: 'absolute',
        left: 10 + 'px',
        top: 35 + 'px',
        width: (this.uiDisplayRightPanelWidth - 20) + 'px',
        height: (this.uiDisplayHeight - (57 + 35)) + 'px',
        backgroundColor: 'transparent',
        fontSize: '14px',
        color: '#88ffff',
        overflow: 'auto',
        scrollbarColor: '#008888 #000000',
        userSelect: 'none'
      });
      this.uiDisplayRightPanel.appendChild(this.uiDisplayRightPanelBody);
      this.uiDisplayRightPanelBody.innerHTML = VolumetricDisplayPrograms.programs[this.programIndex].uiHtml;
      this.thread();
    }, 1);
  },
  getIsOn() {
    return this.isOn;
  },
  setIsOn(isOn) {
    this.isOn = (isOn === true);
    if (this.isOn) {
      VolumetricDisplay.fill();
      VolumetricDisplay.update();
      this.uiDisplay.style.display = 'block';
      const program = VolumetricDisplayPrograms.programs[this.programIndex];
      this.uiDisplayRightPanelHeader.innerText = program.name;
      this.uiDisplayRightPanelBody.innerHTML = program.uiHtml;
      program.init();
    } else {
      VolumetricDisplay.fill();
      VolumetricDisplay.update();
      this.uiDisplay.style.display = 'none';
    }
  },
  thread() {
    if (this.isOn) {
      VolumetricDisplayPrograms.programs[this.programIndex].animate();
    }
    requestAnimationFrame(() => this.thread());
  }
};

const VolumetricDisplayPrograms = {
  programs: [
    {
      name: 'white glass',
      uiHtml: 'All pixels = #FFFFFF06',
      init() {
        VolumetricDisplay.fill({ r: 255, g: 255, b: 255, a: 6 });
        VolumetricDisplay.update();
      },
      animate() {
      }
    },
    {
      name: 'color cube',
      uiHtml: `
        x-pixels = #FF00000A (red)<br />
        y-pixels = #00FF000A (green)<br />
        z-pixels = #0000FF0A (blue)<br />
        <br />
        Look at the display from different angles to see the colors.
      `, 
      init() {
        for (let i = 0, ic = VolumetricDisplay.layersX.length; i < ic; i++) {
          const layer = VolumetricDisplay.layersX[i];
          for (let j = 0, jc = layer.rows.length; j < jc; j++) {
            const row = layer.rows[j];
            for (let k = 0, kc = row.squares.length; k < kc; k++) {
              const square = row.squares[k];
              square.r = 255;
              square.g = 0;
              square.b = 0;
              square.a = 10;
            }
          }
        }
        for (let i = 0, ic = VolumetricDisplay.layersY.length; i < ic; i++) {
          const layer = VolumetricDisplay.layersY[i];
          for (let j = 0, jc = layer.rows.length; j < jc; j++) {
            const row = layer.rows[j];
            for (let k = 0, kc = row.squares.length; k < kc; k++) {
              const square = row.squares[k];
              square.r = 0;
              square.g = 255;
              square.b = 0;
              square.a = 10;
            }
          }
        }
        for (let i = 0, ic = VolumetricDisplay.layersZ.length; i < ic; i++) {
          const layer = VolumetricDisplay.layersZ[i];
          for (let j = 0, jc = layer.rows.length; j < jc; j++) {
            const row = layer.rows[j];
            for (let k = 0, kc = row.squares.length; k < kc; k++) {
              const square = row.squares[k];
              square.r = 0;
              square.g = 0;
              square.b = 255;
              square.a = 10;
            }
          }
        }
        VolumetricDisplay.update();
      },
      animate() {
      }
    },
    {
      name: 'fire',
      uiHtml: `
        Doom fire algorithm with 3D voxels.
        Best viewed from far away.<br />
        <b>Photosensitive seizure warning</b>: Do not zoom into the bright rapid flashes of the fire.<br />
        <span style="line-height: 30px;"><button id="pauseFire" title="pause/resume fire" style="border: 1px solid #88ffff; background-color: #000000; color: #88ffff; cursor: pointer;">pause fire</button></span>
        <span style="line-height: 30px;"><button id="resetFire" title="reset fire" style="border: 1px solid #88ffff; background-color: #000000; color: #88ffff; cursor: pointer;">reset fire</button></span>
      `,
      instanceData: {
        paletteRgba: [
          '#07070700', '#1F060604', /*'#671F0704',*/ '#771F0706', '#8F270708', '#9F2F0710',
          '#BF470710', '#C7470710', '#D75F0710', '#D7670F10', '#CF6F0F10', '#CF871F20',
          '#EF9F1F20', '#F7B73F20', '#FFEF8830', '#FFFFE840'
        ].map(color => {
          const x = parseInt(color.slice(1), 16);
          return { r: (x >> 24) & 255, g: (x >> 16) & 255, b: (x >> 8) & 255, a: x & 255 };
        }),
        fireVoxelsXyz: [],
        lastTimeMs: 0,
        isPaused: false,
        requestAnimate: false,
        pauseFireButton: null,
        resetFireButton: null
      },
      init() {
        const buildFireVoxels = () => {
          this.instanceData.fireVoxelsXyz = [];
          for (let x = 0, xc = (VolumetricDisplay.layersX.length - 1); x < xc; x++) {
            const xAr = [];
            for (let y = 0, yc = (VolumetricDisplay.layersY.length - 1); y < yc; y++) {
              const yAr = [];
              for (let z = 0, zc = (VolumetricDisplay.layersZ.length - 1); z < zc; z++) {
                if (y === (yc - 1)) {
                  yAr.push(this.instanceData.paletteRgba.length - 1);
                } else {
                  yAr.push(0);
                }
              }
              xAr.push(yAr);
            }
            this.instanceData.fireVoxelsXyz.push(xAr);
          }
        };
        this.instanceData.lastTimeMs = Date.now();
        this.instanceData.pauseFireButton = VolumetricDisplayControl.uiDisplayRightPanelBody.querySelector('#pauseFire');
        if (this.instanceData.isPaused) {
          this.instanceData.pauseFireButton.innerText = 'resume fire';
          this.instanceData.pauseFireButton.style.backgroundColor = '#88ffff';
          this.instanceData.pauseFireButton.style.color = '#000000';
        } else {
          this.instanceData.pauseFireButton.innerText = 'pause fire';
          this.instanceData.pauseFireButton.style.backgroundColor = '#000000';
          this.instanceData.pauseFireButton.style.color = '#88ffff';
        }
        this.instanceData.pauseFireButton.addEventListener('click', (event) => {
          event.stopPropagation();
          event.preventDefault();
          this.instanceData.isPaused = !this.instanceData.isPaused;
          if (this.instanceData.isPaused) {
            this.instanceData.pauseFireButton.innerText = 'resume fire';
            this.instanceData.pauseFireButton.style.backgroundColor = '#88ffff';
            this.instanceData.pauseFireButton.style.color = '#000000';
          } else {
            this.instanceData.pauseFireButton.innerText = 'pause fire';
            this.instanceData.pauseFireButton.style.backgroundColor = '#000000';
            this.instanceData.pauseFireButton.style.color = '#88ffff';
          }
        });
        this.instanceData.resetFireButton = VolumetricDisplayControl.uiDisplayRightPanelBody.querySelector('#resetFire');
        this.instanceData.resetFireButton.addEventListener('click', (event) => {
          event.stopPropagation();
          event.preventDefault();
          buildFireVoxels();
          this.instanceData.requestAnimate = true;
          this.instanceData.resetFireButton.style.backgroundColor = '#88ffff';
          this.instanceData.resetFireButton.style.color = '#000000';
          setTimeout(() => {
            this.instanceData.resetFireButton.style.backgroundColor = '#000000';
            this.instanceData.resetFireButton.style.color = '#88ffff';
          }, 200);
        });
        if (this.instanceData.fireVoxelsXyz.length === 0) {
          buildFireVoxels();
        } else {
          this.instanceData.requestAnimate = true;
        }
        VolumetricDisplay.fill();
        VolumetricDisplay.update();
      },
      animate() {
        if (this.instanceData.isPaused && !this.instanceData.requestAnimate) {
          return;
        }
        const timeMs = Date.now();
        if (((timeMs - this.instanceData.lastTimeMs) > 30) || this.instanceData.requestAnimate) {
          this.instanceData.lastTimeMs = timeMs;
          if (!this.instanceData.isPaused) {
            for (let y = 0, yc = (VolumetricDisplay.layersY.length - 2); y < yc; y++) {
              for (let x = 0, xc = (VolumetricDisplay.layersX.length - 1); x < xc; x++) {
                for (let z = 0, zc = (VolumetricDisplay.layersZ.length - 1); z < zc; z++) {
                  const fireVoxelSource = this.instanceData.fireVoxelsXyz[x][y+1][z];
                  const decay = (Math.random() * 2.7) | 0;
                  const destX = (xc + x + (((Math.random() * 2) | 0) - 1)) % xc;
                  const destZ = (zc + z + (((Math.random() * 2) | 0) - 1)) % zc;
                  const heat = Math.max(0, fireVoxelSource - decay);
                  this.instanceData.fireVoxelsXyz[destX][y][destZ] = heat;
                }
              }
            }
          }
          VolumetricDisplay.fill();
          for (let x = 0, xc = this.instanceData.fireVoxelsXyz.length; x < xc; x++) {
            const xAr = this.instanceData.fireVoxelsXyz[x];
            for (let y = (xAr.length - 1); y >= 0; y--) {
              const yAr = xAr[y];
              for (let z = 0, zc = yAr.length; z < zc; z++) {
                const color = this.instanceData.paletteRgba[yAr[z]];
                if (color.a > 0) {
                  VolumetricDisplay.fillVoxel({ x: x, y: y, z: z, r: color.r, g: color.g, b: color.b, a: color.a });
                }
              }
            }
          }
          const bottomY = (VolumetricDisplay.layersY.length - 1);
          for (let x = 0, xc = (VolumetricDisplay.layersX.length - 1); x < xc; x++) {
            for (let z = 0, zc = (VolumetricDisplay.layersZ.length - 1); z < zc; z++) {
              const square = VolumetricDisplay.layersY[bottomY].rows[z].squares[x];
              square.r = 255;
              square.g = 255;
              square.b = 255;
              square.a = 180;
            }
          }
          VolumetricDisplay.update();
        }
        this.instanceData.requestAnimate = false;
      }
    },
    {
      name: 'ripple',
      uiHtml: `
        <span style="line-height: 30px;"><button id="pauseRipple" title="pause/resume ripple" style="border: 1px solid #88ffff; background-color: #000000; color: #88ffff; cursor: pointer;">pause ripple</button></span>
      `,
      instanceData: {
        timeMs: 0,
        lastTimeMs: 0,
        isPaused: false,
        requestAnimate: false,
        pauseRippleButton: null
      },
      init() {
        this.instanceData.pauseRippleButton = VolumetricDisplayControl.uiDisplayRightPanelBody.querySelector('#pauseRipple');
        if (this.instanceData.isPaused) {
          this.instanceData.pauseRippleButton.innerText = 'resume ripple';
          this.instanceData.pauseRippleButton.style.backgroundColor = '#88ffff';
          this.instanceData.pauseRippleButton.style.color = '#000000';
        } else {
          this.instanceData.lastTimeMs = Date.now();
          this.instanceData.pauseRippleButton.innerText = 'pause ripple';
          this.instanceData.pauseRippleButton.style.backgroundColor = '#000000';
          this.instanceData.pauseRippleButton.style.color = '#88ffff';
        }
        this.instanceData.pauseRippleButton.addEventListener('click', (event) => {
          event.stopPropagation();
          event.preventDefault();
          this.instanceData.isPaused = !this.instanceData.isPaused;
          if (this.instanceData.isPaused) {
            this.instanceData.pauseRippleButton.innerText = 'resume ripple';
            this.instanceData.pauseRippleButton.style.backgroundColor = '#88ffff';
            this.instanceData.pauseRippleButton.style.color = '#000000';
            this.instanceData.requestAnimate = true;
          } else {
            this.instanceData.lastTimeMs = Date.now();
            this.instanceData.pauseRippleButton.innerText = 'pause ripple';
            this.instanceData.pauseRippleButton.style.backgroundColor = '#000000';
            this.instanceData.pauseRippleButton.style.color = '#88ffff';
          }
        });        
        VolumetricDisplay.fill();
        VolumetricDisplay.update();
        if (this.instanceData.isPaused) {
          this.instanceData.requestAnimate = true;
        } else {
          this.instanceData.lastTimeMs = Date.now();
        }
      },
      animate() {
        if (this.instanceData.isPaused && !this.instanceData.requestAnimate) {
          return;
        }
        if (!this.instanceData.isPaused) {
          this.instanceData.timeMs += (Date.now() - this.instanceData.lastTimeMs) | 0;
        }
        this.instanceData.lastTimeMs = Date.now();
        const timeMs = this.instanceData.timeMs;
        VolumetricDisplay.fill();
        const centerX = ((VolumetricDisplay.layersX.length - 1) / 2) | 0;
        const centerY = ((VolumetricDisplay.layersY.length - 1) / 2) | 0;
        const centerZ = ((VolumetricDisplay.layersZ.length - 1) / 2) | 0;
        const bottomY = (VolumetricDisplay.layersY.length - 1);
        for (let x = 0, xc = (VolumetricDisplay.layersX.length - 1); x < xc; x++) {
          for (let z = 0, zc = (VolumetricDisplay.layersZ.length - 1); z < zc; z++) {
            const distanceFromCenter = Math.sqrt(((x - centerX) * (x - centerX)) + ((z - centerZ) * (z - centerZ)));
            const angle = ((0.5 * (timeMs / 1000)) - (distanceFromCenter / 10)) * Math.PI;
            const sinVal = Math.sin(angle);
            const cosVal = Math.cos(angle);
            const yTop = bottomY - ((4.5 + (2.5 * sinVal)) | 0);
            if ((yTop >= 0) && (yTop < (VolumetricDisplay.layersY.length - 1))) {
              for (let y = yTop; y < (VolumetricDisplay.layersY.length - 1); y++) {
                VolumetricDisplay.fillVoxel({ x: x, y: y, z: z, r: 0, g: 200 + ((50 * (sinVal)) | 0), b: 200 + ((50 * (sinVal)) | 0), a: 30 });
              }
              const yNormCos = 0.5 + (0.5 * cosVal);
              const square = VolumetricDisplay.layersY[yTop].rows[z].squares[x];
              square.r = 0;
              square.g = 150 + ((100 * yNormCos) | 0);
              square.b = 150 + ((100 * yNormCos) | 0);
              square.a = 200;
            }
          }
        }
        for (let x = 0, xc = (VolumetricDisplay.layersX.length - 1); x < xc; x++) {
          for (let z = 0, zc = (VolumetricDisplay.layersZ.length - 1); z < zc; z++) {
            const square = VolumetricDisplay.layersY[bottomY].rows[z].squares[x];
            square.r = 0;
            square.g = 125;
            square.b = 125;
            square.a = 255;
          }
        }
        VolumetricDisplay.update();
        this.instanceData.requestAnimate = false;
      }
    },
    {
      name: 'land and ocean',
      uiHtml: '',
      init() {
        VolumetricDisplay.fill();
        // ocean
        const oceanLevelY = 15;
        for (let y = 19; y >= oceanLevelY; y--) {
          for (let z = 0; z < 20; z++) {
            for (let x = 0; x < 40; x++) { 
              VolumetricDisplay.fillVoxel({ x: x, y: y, z: z, r: 52, g: 125, b: 204, a: 20 }); 
            }
          }
        }
        // ocean top
        for (let z = 0; z < 20; z++) {
          for (let x = 0; x < 40; x++) {
            const square = VolumetricDisplay.layersY[oceanLevelY].rows[z].squares[x];
            square.a = 90;
          }
        }
        // ocean bottom
        for (let z = 0; z < 20; z++) {
          for (let x = 0; x < 40; x++) {
            const square = VolumetricDisplay.layersY[20].rows[z].squares[x];
            square.r = 10;
            square.g = 77;
            square.b = 100;
            square.a = 255;
          }
        }
        // land 0
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 19, r: 118, g: 83, b: 56, a: 255 }); }
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 18, r: 118, g: 83, b: 56, a: 255 }); }
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 17, r: 118, g: 83, b: 56, a: 255 }); }
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 16, r: 118, g: 83, b: 56, a: 255 }); }
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 15, r: 118, g: 83, b: 56, a: 255 }); }
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 14, r: 118, g: 83, b: 56, a: 255 }); }
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 13, r: 118, g: 83, b: 56, a: 255 }); }
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 12, r: 118, g: 83, b: 56, a: 255 }); }
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 11, r: 118, g: 83, b: 56, a: 255 }); }
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 10, r: 118, g: 83, b: 56, a: 255 }); }
        for (let x = 19; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 19, z: 9, r: 118, g: 83, b: 56, a: 255 }); }
        // land 1
        for (let x = 20; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 18, z: 19, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 20; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 18, z: 18, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 20; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 18, z: 17, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 20; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 18, z: 16, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 20; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 18, z: 15, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 20; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 18, z: 14, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 20; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 18, z: 13, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 20; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 18, z: 12, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 20; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 18, z: 11, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 20; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 18, z: 10, r: 148, g: 106, b: 73, a: 255 }); }
        // land 2
        for (let x = 21; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 17, z: 19, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 21; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 17, z: 18, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 21; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 17, z: 17, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 21; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 17, z: 16, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 21; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 17, z: 15, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 21; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 17, z: 14, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 21; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 17, z: 13, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 21; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 17, z: 12, r: 148, g: 106, b: 73, a: 255 }); }
        for (let x = 21; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 17, z: 11, r: 148, g: 106, b: 73, a: 255 }); }
        // land 3
        for (let x = 22; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 16, z: 19, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 22; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 16, z: 18, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 22; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 16, z: 17, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 22; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 16, z: 16, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 22; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 16, z: 15, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 22; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 16, z: 14, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 22; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 16, z: 13, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 22; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 16, z: 12, r: 206, g: 200, b: 146, a: 255 }); }
        // land 4 - beach
        for (let x = 23; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 15, z: 19, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 23; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 15, z: 18, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 23; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 15, z: 17, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 23; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 15, z: 16, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 23; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 15, z: 15, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 23; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 15, z: 14, r: 206, g: 200, b: 146, a: 255 }); }
        for (let x = 23; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 15, z: 13, r: 206, g: 200, b: 146, a: 255 }); }
        // land 5
        for (let x = 24; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 14, z: 19, r: 183, g: 131, b: 90, a: 255 }); }
        for (let x = 24; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 14, z: 18, r: 183, g: 131, b: 90, a: 255 }); }
        for (let x = 24; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 14, z: 17, r: 183, g: 131, b: 90, a: 255 }); }
        for (let x = 24; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 14, z: 16, r: 183, g: 131, b: 90, a: 255 }); }
        for (let x = 24; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 14, z: 15, r: 183, g: 131, b: 90, a: 255 }); }
        for (let x = 24; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 14, z: 14, r: 183, g: 131, b: 90, a: 255 }); }
        // land 6 - green
        for (let x = 25; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 13, z: 19, r: 90, g: 154, b: 48, a: 255 }); }
        for (let x = 25; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 13, z: 18, r: 90, g: 154, b: 48, a: 255 }); }
        for (let x = 25; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 13, z: 17, r: 90, g: 154, b: 48, a: 255 }); }
        for (let x = 25; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 13, z: 16, r: 90, g: 154, b: 48, a: 255 }); }
        for (let x = 25; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 13, z: 15, r: 90, g: 154, b: 48, a: 255 }); }
        // land 7 - green
        for (let x = 26; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 12, z: 19, r: 90, g: 154, b: 48, a: 255 }); }
        for (let x = 26; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 12, z: 18, r: 90, g: 154, b: 48, a: 255 }); }
        for (let x = 26; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 12, z: 17, r: 90, g: 154, b: 48, a: 255 }); }
        for (let x = 26; x < 40; x++) { VolumetricDisplay.fillVoxel({ x: x, y: 12, z: 16, r: 90, g: 154, b: 48, a: 255 }); }
        VolumetricDisplay.update();
      },
      animate() {
      }
    }    
  ]
};

VolumetricDisplayControl.init();
window.html3dInstance = new HTML3D(document.getElementById('container'), SCENE);

// DOWNLOADLINKSTART
// This code is removed in the downloaded html file.
if (window.location.protocol === 'https:') {
  const headerpanel = document.getElementById('headerpanel');
  const headerpaneldownloadlink = document.createElement('div');
  Object.assign(headerpaneldownloadlink.style, {
    position: 'absolute',
    left: '960px',
    top: '0px',
    width: '40px',
    height: '40px'
  });
  headerpanel.appendChild(headerpaneldownloadlink);
  const downloadlink = document.createElement('div');
  downloadlink.title = 'Download html file with all the code and run it local.';
  Object.assign(downloadlink.style, {
    position: 'absolute',
    left: '8px',
    top: '8px',
    width: '24px',
    height: '24px',
    cursor: 'pointer'
  });
  headerpaneldownloadlink.appendChild(downloadlink);
  const downloadlink_svg = document.createElement('div');
  Object.assign(downloadlink_svg.style, {
    position: 'absolute',
    left: '0px',
    top: '0px',
    width: '24px',
    height: '24px',
    cursor: 'pointer'
  });
  downloadlink_svg.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="position: absolute: left: 0px; top: 0px; width: 24px; height: 24px;">
      <path fill="#ffffff" d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" />
    </svg>
  `;
  downloadlink.appendChild(downloadlink_svg);
  let downloaded = false;
  downloadlink.addEventListener('click', async () => {
    if (downloaded) {
      return;
    }
    downloaded = true;
    downloadlink.title = '';
    downloadlink.style.cursor = 'default';
    downloadlink_svg.style.display = 'none';
    try {
      const response = await fetch(window.location.href);
      let html = await response.text();
      html = html.replace(/\/\/ DOWNLOADLINKSTART[\s\S]*?\/\/ DOWNLOADLINKEND/g, '');
      const blob = new Blob([html], {type: 'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const dateYYYYMMDD = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      a.href = url;
      a.download = `volumetricdisplay_${dateYYYYMMDD}.html`;
      a.click();
      URL.revokeObjectURL(url);
    } catch (error) {
    }
  });
}
// DOWNLOADLINKEND

</script>
</body>
</html>