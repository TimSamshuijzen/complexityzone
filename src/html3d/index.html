<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HTML3D</title>
  <link rel="shortcut icon" type="image/x-png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACXSURBVFhH7ZJBDoAgDAT5Ex/0gfxJ46GJLmxbMAESe5gL6Y5zMOWcz5UkfJhNBFQBRyldsC16Ga8AlHvp3S4PkM1+ASMikeGbBQ2wQJHI8M1iSoC1uYmAvQNwxGC3mscMwIEGu9dcEWAGsGELdqt5XAEtUBQBEaAFaNAAPPQwsmsG4JGXke2/A57f/PwPsC16GVXAbCLgAsl4Px2oefF5AAAAAElFTkSuQmCC">
  <style>
    a, a:link, a:visited, a:hover, a:active {
      text-decoration: inherit;
      font-family: inherit;
      font-size: inherit;
      background-color: inherit;
      color: inherit;
    }
  </style>
</head>
<body style="margin: 0; overflow: hidden; background-color: #b5e7f7; font-family: Arial, sans-serif;">
  <div style="position: absolute; top: 50%; left: 0; width: 100%; height: 50%; background-color: #F2DEC4;"></div>
  <div id="container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
  <div id="headerpanel" style="position: absolute; top: 0; left: 0; width: 100%; height: 40px; background-color: #333333;">
    <div style="position: absolute; left: 20px; top: 0px; width: 200px; height: 40px; color: #cccccc;">
      <a href="https://complexity.zone/"><span style="color: #80cccc; font-size: 16px; line-height: 40px;">complexity.zone</span></a>
    </div>
    <div style="position: absolute; left: 220px; top: 0px; width: 200px; height: 40px; font-size: 18px; line-height: 40px; color: #cccccc;">
      HTML3D
    </div>
  </div>
  <script>

class HTML3D {
  constructor(container, scene) {
    this.camera = {
      x: ((typeof scene?.camera?.x === 'number') ? scene.camera.x : 0),
      y: ((typeof scene?.camera?.y === 'number') ? scene.camera.y : 0),
      z: ((typeof scene?.camera?.z === 'number') ? scene.camera.z : 0),
      rotationX: ((typeof scene?.camera?.rotationX === 'number') ? scene.camera.rotationX : 0),
      rotationY: ((typeof scene?.camera?.rotationY === 'number') ? scene.camera.rotationY : 0),
      collisionWidth: ((typeof scene?.camera?.collisionWidth === 'number') ? scene.camera.collisionWidth : 300),
      collisionHeight: ((typeof scene?.camera?.collisionHeight === 'number') ? scene.camera.collisionHeight : 600),
      fov: ((typeof scene?.camera?.fov === 'number') ? scene.camera.fov : 70),
      worldMatrix: new HTML3D.Matrix4(),
      viewMatrix: new HTML3D.Matrix4(),
      updateWorldMatrix() {
        this.worldMatrix.setTranslate(this.x, this.y, this.z);
        this.worldMatrix.multiply(new HTML3D.Matrix4().setRotateY(this.rotationY));
        this.worldMatrix.multiply(new HTML3D.Matrix4().setRotateX(this.rotationX));
      }
    };
    this.camera.updateWorldMatrix();
    this.container = container;
    this.cameraContainer = document.createElement('div');
    Object.assign(this.cameraContainer.style, {
      position: 'absolute',
      width: '100%',
      height: '100%',
      pointerEvents: 'none'
    });
    this.container.appendChild(this.cameraContainer);
    this.sceneContainer = document.createElement('div');
    Object.assign(this.sceneContainer.style, {
      position: 'absolute',
      width: '100%',
      height: '100%',
      transformStyle: 'preserve-3d'
    });
    this.cameraContainer.appendChild(this.sceneContainer);
    this.panels = [];
    if (Array.isArray(scene?.panels)) {
      for (const scenePanel of scene.panels) {
        const panel = new HTML3D.Panel(this, scenePanel);
        this.panels.push(panel);
      }
    }
    for (const panel of this.panels) {
      if (panel.init !== null) {
        panel.init(this, panel);
      }
    }
    this.requestRender = true;
    this.keyboard = {};
    document.addEventListener('keydown', (event) => {
      if ((document.activeElement.tagName !== 'TEXTAREA') && (document.activeElement.tagName !== 'INPUT')) {
        this.keyboard[event.code] = true;
        // In some cases the keyup event is not triggered, so we help the user get out of the stuck keys situation.
        if (event.code === 'Escape') {
          this.keyboard = {};
        } else if ((event.code === 'ArrowLeft') || (event.code === this.keyboard['KeyA'])) {
          this.keyboard['ArrowRight'] = false;
          this.keyboard['KeyD'] = false;
        } else if ((event.code === 'ArrowRight') || (event.code === this.keyboard['KeyD'])) {
          this.keyboard['ArrowLeft'] = false;
          this.keyboard['KeyA'] = false;
        } else if ((event.code === 'ArrowUp') || (event.code === this.keyboard['KeyW'])) {
          this.keyboard['ArrowDown'] = false;
          this.keyboard['KeyS'] = false;
        } else if ((event.code === 'ArrowDown') || (event.code === this.keyboard['KeyS'])) {
          this.keyboard['ArrowUp'] = false;
          this.keyboard['KeyW'] = false;
        } else if (event.code === 'KeyZ') {
          this.keyboard['KeyX'] = false;
        } else if (event.code === 'KeyX') {
          this.keyboard['KeyZ'] = false;
        }
      }
    });
    document.addEventListener('keyup', (event) => { 
      this.keyboard[event.code] = false; 
    });
    window.addEventListener('resize', () => { this.requestRender = true; });
    this._thread();
  }
  export() {
    return {
      camera: {
        x: this.camera.x,
        y: this.camera.y,
        z: this.camera.z,
        rotationX: this.camera.rotationX,
        rotationY: this.camera.rotationY,
        collisionWidth: this.camera.collisionWidth,
        collisionHeight: this.camera.collisionHeight,
        fov: this.camera.fov
      },
      panels: this.panels.map((panel) => {
        return panel.export();
      })
    };
  }
  import(scene) {
    for (const panel of this.panels) {
      panel.element.remove();
    }
    this.panels = [];
    if (scene?.camera) {
      this.camera.x = (scene.camera.x !== undefined) ? scene.camera.x : 0;
      this.camera.y = (scene.camera.y !== undefined) ? scene.camera.y : 0;
      this.camera.z = (scene.camera.z !== undefined) ? scene.camera.z : 0;
      this.camera.rotationX = (scene.camera.rotationX !== undefined) ? scene.camera.rotationX : 0;
      this.camera.rotationY = (scene.camera.rotationY !== undefined) ? scene.camera.rotationY : 0;
      this.camera.collisionWidth = (scene.camera.collisionWidth !== undefined) ? scene.camera.collisionWidth : 300;
      this.camera.collisionHeight = (scene.camera.collisionHeight !== undefined) ? scene.camera.collisionHeight : 700;
      this.camera.fov = (scene.camera.fov !== undefined) ? scene.camera.fov : 70;
      this.camera.updateWorldMatrix();
    }
    if (Array.isArray(scene?.panels)) {
      for (const panelData of scene.panels) {
        this.panels.push(new HTML3D.Panel(this, panelData));
      }
    }
    for (const panel of this.panels) {
      if (panel.init !== null) {
        panel.init(this, panel);
      }
    }
    this.requestRender = true;
  }
  render() {
    const innerWidth = this.container.clientWidth;
    const innerHeight = this.container.clientHeight;
    const focalLength = (0.5 * innerHeight) / Math.tan((this.camera.fov * 0.5 * Math.PI) / 180);
    this.camera.viewMatrix.setMatrix(this.camera.worldMatrix).invert();
    this.sceneContainer.style.transform = `perspective(${focalLength}px) translateZ(${focalLength}px) ${this.camera.viewMatrix.toCSSMatrixString()} translate(${innerWidth / 2}px, ${innerHeight / 2}px)`;
    for (let i = 0, c = this.panels.length; i < c; i++) {
      this.panels[i].render();
    }
  }
  _thread() {
    if (this._moveCamera()) {
      this.requestRender = true;
    }
    if (this.requestRender) {
      this.requestRender = false;
      this.render();
    }
    for (let i = 0, c = this.panels.length; i < c; i++) {
      const panel = this.panels[i];
      if (panel.animate !== null) {
        panel.animate(this, panel);
      }
    }
    requestAnimationFrame(() => this._thread());
  }
  _moveCamera() {
    let result = false;
    const moveSpeed = 2500 * (1 / 60);
    const rotateSpeed = (Math.PI * 0.5) * (1 / 60);
    const forward = new HTML3D.Vector3(0, 0, -1);
    forward.applyMatrix4Rotation(this.camera.worldMatrix);
    forward.y = 0;
    forward.normalize();
    const right = new HTML3D.Vector3(this.camera.worldMatrix.elements[0], this.camera.worldMatrix.elements[1], this.camera.worldMatrix.elements[2]);
    right.y = 0;
    right.normalize();
    if ((this.keyboard['ArrowLeft']) || (this.keyboard['KeyA'])) {
      this.camera.rotationY += rotateSpeed;
      result = true;
    }
    if ((this.keyboard['ArrowRight']) || (this.keyboard['KeyD'])) {
      this.camera.rotationY -= rotateSpeed;
      result = true;
    }
    const intendedMove = new HTML3D.Vector3(0, 0, 0);
    if ((this.keyboard['ArrowUp']) || (this.keyboard['KeyW'])) {
      intendedMove.add(forward);
    }
    if ((this.keyboard['ArrowDown']) || (this.keyboard['KeyS'])) {
      intendedMove.sub(forward);
    }
    if (this.keyboard['KeyZ']) { 
      intendedMove.sub(right); 
    }
    if (this.keyboard['KeyX']) { 
      intendedMove.add(right);
    }
    if (intendedMove.lengthSq() > 0) {
      intendedMove.normalize();
      intendedMove.multiplyScalar(moveSpeed);
      const finalMove = intendedMove.clone();
      const moveX = new HTML3D.Vector3(intendedMove.x, 0, 0);
      if (this._checkAABBCollision(moveX)) {
        finalMove.x = 0;
      }
      const moveZ = new HTML3D.Vector3(0, 0, intendedMove.z);
      if (this._checkAABBCollision(moveZ)) {
        finalMove.z = 0;
      }
      if (finalMove.lengthSq() > 0) {
        result = true;
        this.camera.x += finalMove.x;
        this.camera.y += finalMove.y;
        this.camera.z += finalMove.z;
      }
    }
    if (result) {
      this.camera.updateWorldMatrix();
    }
    return result;
  }
  _checkAABBCollision(moveDirection) {
    const targetPosition = new HTML3D.Vector3(this.camera.x, this.camera.y, this.camera.z);
    targetPosition.add(moveDirection);
    const halfCameraWidth = (this.camera.collisionWidth / 2);
    const cameraBoundingBox = new HTML3D.BoundingBox(
      new HTML3D.Vector3(targetPosition.x - halfCameraWidth, (targetPosition.y - 10), targetPosition.z - halfCameraWidth),
      new HTML3D.Vector3(targetPosition.x + halfCameraWidth, (targetPosition.y + this.camera.collisionHeight), targetPosition.z + halfCameraWidth)
    );
    for (let i = 0, c = this.panels.length; i < c; i++) {
      const panel = this.panels[i];
      if (panel.boundingBox) {
        if (cameraBoundingBox.intersectsBox(panel.boundingBox)) {
          return true;
        }
      }
    }
    return false;
  }
}
{
  HTML3D.Panel = class Panel {
    constructor(html3d, scenePanel) {
      this.html3d = html3d;
      Object.assign(this, {
        id: ((typeof scenePanel.id === 'string') ? scenePanel.id : null),
        relativeToId: ((typeof scenePanel.relativeToId === 'string') ? scenePanel.relativeToId : null),
        title: ((typeof scenePanel.title === 'string') ? scenePanel.title : null),
        width: ((typeof scenePanel.width === 'number') ? scenePanel.width : 100),
        height: ((typeof scenePanel.height === 'number') ? scenePanel.height : 100),
        anchorCenter: ((typeof scenePanel.anchorCenter === 'boolean') ? scenePanel.anchorCenter : false),
        x: ((typeof scenePanel.x === 'number') ? scenePanel.x : 0),
        y: ((typeof scenePanel.y === 'number') ? scenePanel.y : 0),
        z: ((typeof scenePanel.z === 'number') ? scenePanel.z : 0),
        rotationX: ((typeof scenePanel.rotationX === 'number') ? scenePanel.rotationX : 0),
        rotationY: ((typeof scenePanel.rotationY === 'number') ? scenePanel.rotationY : 0),
        backgroundColor: ((typeof scenePanel.backgroundColor === 'string') ? scenePanel.backgroundColor : 'transparent'),
        backgroundImage: ((typeof scenePanel.backgroundImage === 'string') ? scenePanel.backgroundImage : null),
        backgroundTileImage: ((typeof scenePanel.backgroundTileImage === 'string') ? scenePanel.backgroundTileImage : null),
        opacity: ((typeof scenePanel.opacity === 'number') ? scenePanel.opacity : null),
        obstruction: ((typeof scenePanel.obstruction === 'boolean') ? scenePanel.obstruction : false),
        interaction: ((typeof scenePanel.interaction === 'boolean') ? scenePanel.interaction : false),
        innerHTML: ((typeof scenePanel.innerHTML === 'string') ? scenePanel.innerHTML : null),
        iframeSrc: ((typeof scenePanel.iframeSrc === 'string') ? scenePanel.iframeSrc : null),
        iframeHtml: ((typeof scenePanel.iframeHtml === 'string') ? scenePanel.iframeHtml : null),
        userData: ((typeof scenePanel.userData === 'object') ? scenePanel.userData : null),
        init: ((typeof scenePanel.init === 'function') ? scenePanel.init : null),
        click: ((typeof scenePanel.click === 'function') ? scenePanel.click : null),
        animate: ((typeof scenePanel.animate === 'function') ? scenePanel.animate : null)
      });
      if (typeof scenePanel.initString === 'string') {
        try {
          this.init = new Function('html3d', 'panel', scenePanel.initString);
        } catch (e) {
          this.init = null;
        }
      }
      if (typeof scenePanel.clickString === 'string') {
        try {
          this.click = new Function('html3d', 'panel', scenePanel.clickString);
        } catch (e) {
          this.click = null;
        }
      }
      if (typeof scenePanel.animateString === 'string') {
        try { 
          this.animate = new Function('html3d', 'panel', scenePanel.animateString);
        } catch (e) {
          this.animate = null;
        }
      }
      this.iframe = null;
      this.element = document.createElement('div');
      if (this.id !== null) {
        this.element.id = this.id;
      }
      if (this.title !== null) {
        this.element.title = this.title;
      }
      Object.assign(this.element.style, {
        position: 'absolute',
        width: this.width + 'px',
        height: this.height + 'px',
        backgroundColor: this.backgroundColor,
        pointerEvents: (((this.interaction === true) || (this.obstruction === true)) ? 'auto' : 'none'),
        userSelect: ((this.interaction === true) ? 'auto' : 'none')
      });
      html3d.sceneContainer.appendChild(this.element);
      if (this.innerHTML !== null) {
        this.element.innerHTML = this.innerHTML;
      } else if ((this.iframeSrc !== null) || (this.iframeHtml !== null)) {
        this.iframe = document.createElement('iframe');
        this.iframe.setAttribute('referrerpolicy', 'strict-origin-when-cross-origin');
        if (this.iframeSrc !== null) {
          this.iframe.src = this.iframeSrc;
        } else if (this.iframeHtml !== null) {
          this.iframe.srcdoc = this.iframeHtml;
        }
        Object.assign(this.iframe.style, {
          position: 'absolute',
          left: '0px',
          top: '0px',
          width: this.width + 'px',
          height: this.height + 'px',
          border: 'none'
        });
        this.element.appendChild(this.iframe);
      } else if (this.backgroundImage !== null) {
        this.element.style.backgroundImage = this.backgroundImage;
        this.element.style.backgroundSize = 'contain';
        this.element.style.backgroundPosition = 'center';
        this.element.style.backgroundRepeat = 'no-repeat';
      } else if (this.backgroundTileImage !== null) {
        this.element.style.backgroundImage = this.backgroundTileImage;
        this.element.style.backgroundRepeat = 'repeat';
      }
      if (this.opacity !== null) {
        this.element.style.opacity = this.opacity;
      }
      if (this.click !== null) {
        this.element.style.cursor = 'pointer';
        this.element.addEventListener('click', (event) => {
          event.stopPropagation();
          this.click(html3d, this);
        });
      }
      this.worldMatrix = new HTML3D.Matrix4();
      this.boundingBox = null;
      this.updateWorldMatrix();
    }
    export() {
      const panelData = {
        id: (this.id !== null) ? this.id : undefined,
        relativeToId: (this.relativeToId !== null) ? this.relativeToId : undefined,
        title: (this.title !== null) ? this.title : undefined,
        width: this.width,
        height: this.height,
        anchorCenter: (this.anchorCenter === true) ? this.anchorCenter : undefined,
        x: this.x,
        y: this.y,
        z: this.z,
        rotationX: (this.rotationX !== 0) ? this.rotationX : undefined,
        rotationY: (this.rotationY !== 0) ? this.rotationY : undefined,
        backgroundColor: this.backgroundColor,
        backgroundImage: (this.backgroundImage !== null) ? this.backgroundImage : undefined,
        backgroundTileImage: (this.backgroundTileImage !== null) ? this.backgroundTileImage : undefined,
        opacity: (this.opacity !== null) ? this.opacity : undefined,
        obstruction: (this.obstruction !== null) ? this.obstruction : undefined,
        interaction: (this.interaction !== null) ? this.interaction : undefined,
        innerHTML: (this.innerHTML !== null) ? this.innerHTML : undefined,
        iframeSrc: (this.iframeSrc !== null) ? this.iframeSrc : undefined,
        iframeHtml: (this.iframeHtml !== null) ? this.iframeHtml : undefined
      };
      if (this.userData !== null) {
        panelData.userData = {};
        for (const key in this.userData) {
          if (this.userData.hasOwnProperty(key)) {
            panelData.userData[key] = this.userData[key];
          }
        }
      }
      if (this.init !== null) {
        panelData.initString = this.init.toString();
        panelData.initString = panelData.initString.substring(panelData.initString.indexOf('{') + 1, panelData.initString.lastIndexOf('}')).trim();
      }
      if (this.click !== null) {
        panelData.clickString = this.click.toString();
        panelData.clickString = panelData.clickString.substring(panelData.clickString.indexOf('{') + 1, panelData.clickString.lastIndexOf('}')).trim();
      }
      if (this.animate !== null) {
        panelData.animateString = this.animate.toString();
        panelData.animateString = panelData.animateString.substring(panelData.animateString.indexOf('{') + 1, panelData.animateString.lastIndexOf('}')).trim();
      }
      return panelData;
    }
    updateWorldMatrix() {
      this.worldMatrix.reset();
      if (this.relativeToId !== null) {
        const relativeToPanel = this.html3d.panels.find((panel) => panel.id === this.relativeToId);
        if (relativeToPanel) {
          this.worldMatrix.setMatrix(relativeToPanel.worldMatrix);
        }
      }
      this.worldMatrix.multiply(new HTML3D.Matrix4().setTranslate(this.x, this.y, this.z)).multiply(new HTML3D.Matrix4().setRotateY(this.rotationY)).multiply(new HTML3D.Matrix4().setRotateX(this.rotationX));
      if (this.obstruction === true) {
        const eitherSide = 10;
        if (this.anchorCenter === true) {
          this.boundingBox = new HTML3D.BoundingBox(
            new HTML3D.Vector3(-this.width / 2, -this.height / 2, -eitherSide),
            new HTML3D.Vector3(this.width / 2, this.height / 2, eitherSide)
          );
        } else {
          this.boundingBox = new HTML3D.BoundingBox(
            new HTML3D.Vector3(0, 0, -eitherSide),
            new HTML3D.Vector3(this.width, this.height, eitherSide)
          );
        }
        this.boundingBox.applyMatrix4(this.worldMatrix);
      } else {
        this.boundingBox = null;
      }
      for (const panel of this.html3d.panels) {
        if (panel.relativeToId === this.id) {
          panel.updateWorldMatrix();
        }
      }
    }
    render() {
      this.element.style.transform = `translate(-50%, -50%) ${this.worldMatrix.toCSSMatrixString()}${this.anchorCenter ? '' : ' translate(50%, 50%)'}`;
    }
  }
  HTML3D.Vector3 = class Vector3 {
    constructor(x = 0, y = 0, z = 0) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    set(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
    clone() {
      return new HTML3D.Vector3(this.x, this.y, this.z);
    }
    add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    multiplyScalar(s) {
      this.x *= s;
      this.y *= s;
      this.z *= s;
      return this;
    }
    lengthSq() {
      return (this.x * this.x) + (this.y * this.y) + (this.z * this.z);
    }
    length() {
      return Math.sqrt(this.lengthSq());
    }
    normalize() {
      const l = this.length();
      if (l > 0.00001) {
        this.multiplyScalar(1 / l);
      }
      return this;
    }
    applyMatrix4(m) {
      const x = this.x;
      const y = this.y;
      const z = this.z;
      const e = m.elements;
      const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    applyMatrix4Rotation(m) {
      const x = this.x;
      const y = this.y;
      const z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
    dot(v) {
      return (this.x * v.x) + (this.y * v.y) + (this.z * v.z);
    }
  }
  HTML3D.Matrix4 = class Matrix4 {
    constructor() {
      this.reset();
    }
    reset() {
      this.elements = [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
      ];
      return this;
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      const te = this.elements;
      te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
      te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
      te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
      te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;
      return this;
    }
    setMatrix(m) {
      this.elements = [...m.elements];
      return this;
    }
    clone() {
      const newMatrix = new HTML3D.Matrix4();
      newMatrix.elements = [...this.elements];
      return newMatrix;
    }
    setTranslate(x, y, z) {
      return this.set(
        1, 0, 0, x,
        0, 1, 0, y,
        0, 0, 1, z,
        0, 0, 0, 1
      );
    }
    setRotateX(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      return this.set(
        1, 0, 0, 0,
        0, c, -s, 0,
        0, s, c, 0,
        0, 0, 0, 1
      );
    }
    setRotateY(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      return this.set(
        c, 0, s, 0,
        0, 1, 0, 0,
        -s, 0, c, 0,
        0, 0, 0, 1
      );
    }
    multiply(m) {
      const me = m.elements;
      const te = this.elements;
      const a11 = te[0], a12 = te[4], a13 = te[8], a14 = te[12];
      const a21 = te[1], a22 = te[5], a23 = te[9], a24 = te[13];
      const a31 = te[2], a32 = te[6], a33 = te[10], a34 = te[14];
      const a41 = te[3], a42 = te[7], a43 = te[11], a44 = te[15];
      const b11 = me[0], b12 = me[4], b13 = me[8], b14 = me[12];
      const b21 = me[1], b22 = me[5], b23 = me[9], b24 = me[13];
      const b31 = me[2], b32 = me[6], b33 = me[10], b34 = me[14];
      const b41 = me[3], b42 = me[7], b43 = me[11], b44 = me[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
    invert() {
      const te = this.elements;
      const r11 = te[0], r12 = te[4], r13 = te[8];
      const r21 = te[1], r22 = te[5], r23 = te[9];
      const r31 = te[2], r32 = te[6], r33 = te[10];
      const tx = te[12], ty = te[13], tz = te[14];
      te[0] = r11; te[4] = r21; te[8] = r31;
      te[1] = r12; te[5] = r22; te[9] = r32;
      te[2] = r13; te[6] = r23; te[10] = r33;
      te[12] = -(te[0] * tx + te[4] * ty + te[8] * tz);
      te[13] = -(te[1] * tx + te[5] * ty + te[9] * tz);
      te[14] = -(te[2] * tx + te[6] * ty + te[10] * tz);
      return this;
    }
    toCSSMatrixString() {
      const e = this.elements;
      return 'matrix3d(' +
        e[0] + ',' + e[1] + ',' + e[2] + ',' + e[3] + ',' +
        e[4] + ',' + e[5] + ',' + e[6] + ',' + e[7] + ',' +
        e[8] + ',' + e[9] + ',' + e[10] + ',' + e[11] + ',' +
        e[12] + ',' + e[13] + ',' + e[14] + ',' + e[15] +
        ')';
    }
  }
  HTML3D.BoundingBox = class BoundingBox {
    constructor(min = new HTML3D.Vector3(+Infinity, +Infinity, +Infinity), max = new HTML3D.Vector3(-Infinity, -Infinity, -Infinity)) {
      this.min = min;
      this.max = max;
    }
    applyMatrix4(matrix) {
      const points = [
        new HTML3D.Vector3(this.min.x, this.min.y, this.min.z),
        new HTML3D.Vector3(this.min.x, this.min.y, this.max.z),
        new HTML3D.Vector3(this.min.x, this.max.y, this.min.z),
        new HTML3D.Vector3(this.min.x, this.max.y, this.max.z),
        new HTML3D.Vector3(this.max.x, this.min.y, this.min.z),
        new HTML3D.Vector3(this.max.x, this.min.y, this.max.z),
        new HTML3D.Vector3(this.max.x, this.max.y, this.min.z),
        new HTML3D.Vector3(this.max.x, this.max.y, this.max.z),
      ];
      this.min.set(+Infinity, +Infinity, +Infinity);
      this.max.set(-Infinity, -Infinity, -Infinity);
      for (let i = 0; i < 8; i++) {
        points[i].applyMatrix4(matrix);
        this.min.x = Math.min(this.min.x, points[i].x);
        this.min.y = Math.min(this.min.y, points[i].y);
        this.min.z = Math.min(this.min.z, points[i].z);
        this.max.x = Math.max(this.max.x, points[i].x);
        this.max.y = Math.max(this.max.y, points[i].y);
        this.max.z = Math.max(this.max.z, points[i].z);
      }
      return this;
    }
    intersectsBox(box) {
      return this.max.x >= box.min.x && this.min.x <= box.max.x &&
        this.max.y >= box.min.y && this.min.y <= box.max.y &&
        this.max.z >= box.min.z && this.min.z <= box.max.z;
    }
  }
}

// =====================================================================
// scene

const cameraHeight = 900;
const buildingWidth = 10000;
const buildingDepth = 7500;
const wallHeight = 1750;
const doorWidth = 1500;
const floorDepth = 200;
const firstFloorWallDepth = 200;
const firstFloorWindowWidth = (buildingWidth / 2) - 1000;
const firstFloorWindowHeight = 1000;
const pageCode = document.documentElement.outerHTML;
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();
const audioCtxMainGain = audioCtx.createGain();
const audioCtxMainGainVolume = 0.5;
audioCtxMainGain.connect(audioCtx.destination);
audioCtxMainGain.gain.setValueAtTime(audioCtxMainGainVolume, audioCtx.currentTime);
function initAudioContext() {
  if (audioCtx.state === 'suspended') {
    return audioCtx.resume();
  }
  return Promise.resolve();
}

const scene_HTML3Ddemo = {
  camera: {
    x: doorWidth / 2,
    y: -cameraHeight,
    z: 10600,
    rotationY: 0,
    collisionWidth: 300,
    collisionHeight: (cameraHeight - 200)
  },
  panels: [
    {
      id: 'instructions',
      width: 1500,
      height: 1500,
      x: -1500, 
      y: -1500,
      z: 8200,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#303030',
      opacity: 0.8,
      innerHTML: `
        <div style="position: absolute; left: 0px; top: 0px; width: 1500px; height: 150px; background-color: #000000;">
          <div style="position: absolute; left: 100px; top: 0px; width: 1400px; height: 150px; color: #ffffff; font-size: 100px; line-height: 150px;">
            HTML3D
          </div>
        </div>
        <div style="position: absolute; left: 100px; top: 200px; width: 1100px; height: 150px; color: #ffffff; font-size: 100px;">
          move / turn
        </div>
        <div style="position: absolute; left: 200px; top: 350px; width: 1300px; height: 420px;">
          <div style="position: absolute; left: 0px; top: 0px; width: 380px; height: 250px;">
            <div style="position: absolute; left: 130px; top: 0px; width: 100px; height: 100px; border: 10px solid #ffffff; border-radius: 10px; color: #ffffff; font-size: 80px; line-height: 100px; text-align: center;">
              w
            </div>
            <div style="position: absolute; left: 0px; top: 130px; width: 100px; height: 100px; border: 10px solid #ffffff; border-radius: 10px; color: #ffffff; font-size: 80px; line-height: 100px; text-align: center;">
              a
            </div>
            <div style="position: absolute; left: 130px; top: 130px; width: 100px; height: 100px; border: 10px solid #ffffff; border-radius: 10px; color: #ffffff; font-size: 80px; line-height: 100px; text-align: center;">
              s
            </div>
            <div style="position: absolute; left: 260px; top: 130px; width: 100px; height: 100px; border: 10px solid #ffffff; border-radius: 10px; color: #ffffff; font-size: 80px; line-height: 100px; text-align: center;">
              d
            </div>
          </div>
          <div style="position: absolute; left: 380px; top: 0px; width: 220px; height: 250px; color: #ffffff; font-size: 60px; line-height: 250px; text-align: center;">
            or
          </div>
          <div style="position: absolute; left: 600px; top: 0px; width: 380px; height: 250px;">
            <div style="position: absolute; left: 130px; top: 0px; width: 100px; height: 100px; border: 10px solid #ffffff; border-radius: 10px; color: #ffffff; font-size: 80px; line-height: 100px; text-align: center;">
              ˄
            </div>
            <div style="position: absolute; left: 0px; top: 130px; width: 100px; height: 100px; border: 10px solid #ffffff; border-radius: 10px; color: #ffffff; font-size: 80px; line-height: 100px; text-align: center;">
              ˂
            </div>
            <div style="position: absolute; left: 130px; top: 130px; width: 100px; height: 100px; border: 10px solid #ffffff; border-radius: 10px; color: #ffffff; font-size: 80px; line-height: 100px; text-align: center;">
              ˅
            </div>
            <div style="position: absolute; left: 260px; top: 130px; width: 100px; height: 100px; border: 10px solid #ffffff; border-radius: 10px; color: #ffffff; font-size: 80px; line-height: 100px; text-align: center;">
              ˃
            </div>
          </div>
          <div style="position: absolute; left: 0px; top: 300px; width: 250px; height: 120px;">
            <div style="position: absolute; left: 0px; top: 0px; width: 100px; height: 100px; border: 10px solid #ffffff; border-radius: 10px; color: #ffffff; font-size: 80px; line-height: 100px; text-align: center;">
              z
            </div>
            <div style="position: absolute; left: 130px; top: 0px; width: 100px; height: 100px; border: 10px solid #ffffff; border-radius: 10px; color: #ffffff; font-size: 80px; line-height: 100px; text-align: center;">
              x
            </div>
          </div>
          <div style="position: absolute; left: 300px; top: 300px; width: 800px; height: 120px; color: #ffffff; font-size: 60px; line-height: 120px;">
          </div>  
        </div>
        <div style="position: absolute; left: 100px; top: 850px; width: 1100px; height: 150px; color: #ffffff; font-size: 100px;">
          interact
        </div>
        <div style="position: absolute; left: 200px; top: 1000px; width: 1300px; height: 350px;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="position: absolute; left: 0px; top: 0px; width: 200px; height: 200px;">
            <path fill="#ffffff" d="M11,1.07C7.05,1.56 4,4.92 4,9H11M4,15A8,8 0 0,0 12,23A8,8 0 0,0 20,15V11H4M13,1.07V9H20C20,4.92 16.94,1.56 13,1.07Z" />
          </svg>
          <div style="position: absolute; left: 280px; top: 0px; width: 900px; height: 350px; color: #ffffff; font-size: 42px;">
            All objects are HTML elements, positioned in 3D space with CSS 3D transforms.
            You can click on them to interact. When an input field has focus, the keys for moving and turning are disabled.
            To resume being able to move with the keyboard, click outside the input field.
          </div>
        </div>
      `
    },
    {
      id: 'sceneEditor',
      width: 1650,
      height: 1500,
      x: doorWidth, 
      y: -1500,
      z: 8200,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#303030',
      innerHTML: `
        <div style="position: absolute; left: 0px; top: 0px; width: 1650px; height: 150px; background-color: #000000;">
          <div style="position: absolute; left: 100px; top: 0px; width: 1550px; height: 150px; color: #ffffff; font-size: 100px; line-height: 150px;">
            scene editor
          </div>
        </div>
        <div id="scenejsonTextareaContainer" style="position: absolute; left: 100px; top: 250px; width: 1020px; height: 920px; background-color: transparent; overflow: visible;">
          <textarea id="scenejsonTextarea" style="position: absolute; left: 0px; top: 0px; width: 1000px; height: 900px; background-color: #ffffff; color: #000000; font-size: 20px; font-family: monospace; white-space: nowrap; overflow: auto; resize: none;">
          </textarea>
        </div>
        <div style="position: absolute; left: 1150px; top: 250px; width: 400px; height: 240px; color: #ffffff; font-size: 24px;">
          <span style="font-size: 50px;">🛈</span><br />
          This json code describes the entire scene, including camera position and this scene editor. You can modify the json code and write it to HTML3D.<br />
        </div>
        <button id="scenejsonReadButton" title="Read current scene state (including camera position) from HTML3D and update the editor." style="position: absolute; left: 1150px; top: 500px; width: 400px; height: 50px; font-size: 24px; background-color: #f0f0f0; color: #000000; white-space: nowrap; text-align: left; cursor: pointer;">
          <span style="display: inline-block; width: 26px; height: 26px;"></span>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: inline-block; width: 26px; height: 26px;" fill="#000000" stroke="none">
            <path d="M13,22L3,12L13,2V8H21V16H13V22M6,12L11,17V14H19V10H11V7L6,12Z"></path>
          </svg>
          Read scene from HTML3D
        </button>
        <button id="scenejsonWriteButton" title="Send scene in editor to HTML3D and render the new scene.\nWarning: You will teleport to the new camera position." style="position: absolute; left: 1150px; top: 570px; width: 400px; height: 50px; font-size: 24px; background-color: #f0f0f0; color: #000000; white-space: nowrap; text-align: left; cursor: pointer;">
          <span style="display: inline-block; width: 26px; height: 26px;"></span>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: inline-block; width: 26px; height: 26px;" fill="#000000" stroke="none">
            <path d="M11,16H3V8H11V2L21,12L11,22V16M13,7V10H5V14H13V17L18,12L13,7Z"></path>
          </svg>
          Write scene to HTML3D
        </button>
        <button id="scenejsonCopyToClipboardButton" style="position: absolute; left: 1150px; top: 760px; width: 400px; height: 50px; font-size: 24px; background-color: #f0f0f0; color: #000000; white-space: nowrap; text-align: left; cursor: pointer;">
          <span style="display: inline-block; width: 26px; height: 26px;"></span>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: inline-block; width: 26px; height: 26px;" fill="#000000" stroke="none">
            <path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path>
          </svg>
          Copy scene to clipboard
        </button>
        <button id="scenejsonDownloadFileButton" style="position: absolute; left: 1150px; top: 830px; width: 400px; height: 50px; font-size: 24px; background-color: #f0f0f0; color: #000000; white-space: nowrap; text-align: left; cursor: pointer;">
          <span style="display: inline-block; width: 26px; height: 26px;"></span>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: inline-block; width: 26px; height: 26px;" fill="#000000" stroke="none">
            <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z"></path>
          </svg>
          Download scene json file
        </button>
        <button id="scenejsonLoadFromFileButton" style="position: absolute; left: 1150px; top: 900px; width: 400px; height: 50px; font-size: 24px; background-color: #f0f0f0; color: #000000; white-space: nowrap; text-align: left; cursor: pointer;">
          <span style="display: inline-block; width: 26px; height: 26px;"></span>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: inline-block; width: 26px; height: 26px;" fill="#000000" stroke="none">
            <path d="M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z"></path>
          </svg>
          Open scene json file
        </button>
      `,
      init(html3d, panel) {
        const textarea = document.getElementById('scenejsonTextarea');
        textarea.value = JSON.stringify(html3d.export(), null, 2);
        const scenejsonReadButton = document.getElementById('scenejsonReadButton');
        const scenejsonWriteButton = document.getElementById('scenejsonWriteButton');
        const scenejsonCopyToClipboardButton = document.getElementById('scenejsonCopyToClipboardButton');
        const scenejsonDownloadFileButton = document.getElementById('scenejsonDownloadFileButton');
        const scenejsonLoadFromFileButton = document.getElementById('scenejsonLoadFromFileButton');
        const container = document.getElementById('scenejsonTextareaContainer');
        container.addEventListener('wheel', (event) => {
          event.preventDefault();
          const delta = event.deltaY || event.detail || event.wheelDelta;
          textarea.scrollTop += delta;
        }, { passive: false });
        textarea.addEventListener('input', (event) => {
          const json = textarea.value;
          let jsonObject = undefined;
          try {
            jsonObject = JSON.parse(json);
          } catch (error) {
            jsonObject = undefined;
          }
          textarea.style.backgroundColor = (jsonObject !== undefined) ? '#ffffff' : '#ffeeee';
          scenejsonWriteButton.disabled = (jsonObject === undefined);
          scenejsonWriteButton.style.backgroundColor = (jsonObject !== undefined) ? '#f0f0f0' : '#cccccc';
          scenejsonWriteButton.style.cursor = (jsonObject !== undefined) ? 'pointer' : 'not-allowed';
        });
        scenejsonReadButton.addEventListener('click', () => {
          textarea.value = JSON.stringify(html3d.export(), null, 2);
          textarea.scrollTop = 0;
        });
        scenejsonWriteButton.addEventListener('click', () => {
          let jsonObject = undefined;
          try {
            jsonObject = JSON.parse(textarea.value);
          } catch (error) {
            jsonObject = undefined;
          }
          if (jsonObject !== undefined) {
            html3d.import(jsonObject);
          }
        });
        scenejsonCopyToClipboardButton.addEventListener('click', () => {
          navigator.clipboard.writeText(textarea.value).then(() => {
            scenejsonCopyToClipboardButton.style.backgroundColor = '#ccffcc';
            setTimeout(() => {
              scenejsonCopyToClipboardButton.style.backgroundColor = '#f0f0f0';
            }, 500);
          }).catch((error) => {
          });
        });
        scenejsonDownloadFileButton.addEventListener('click', () => {
          const blob = new Blob([textarea.value], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'scene.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });
        scenejsonLoadFromFileButton.addEventListener('click', () => {
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = '.json';
          fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (e) => {
                const json = e.target.result;
                textarea.value = json;
                let jsonObject = undefined;
                try {
                  jsonObject = JSON.parse(json);
                } catch (error) {
                  jsonObject = undefined;
                }
                textarea.style.backgroundColor = (jsonObject !== undefined) ? '#ffffff' : '#ffeeee';
                scenejsonWriteButton.disabled = (jsonObject === undefined);
                scenejsonWriteButton.style.backgroundColor = (jsonObject !== undefined) ? '#f0f0f0' : '#cccccc';
                scenejsonWriteButton.style.cursor = (jsonObject !== undefined) ? 'pointer' : 'not-allowed';
              };
              reader.readAsText(file);
            }
          });
          fileInput.click();
        });
      }
    },
    {
      id: 'lawnLeft',
      width: buildingWidth / 2,
      height: 5500,
      x: -(buildingWidth / 2), 
      y: 0,
      z: (buildingDepth / 2),
      rotationX: Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#365902'
    },
    {
      id: 'lawnRight',
      width: (buildingWidth / 2) - doorWidth,
      height: 5500,
      x: doorWidth, 
      y: 0,
      z: (buildingDepth / 2),
      rotationX: Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#365902'
    },
    {
      id: 'entrancePath',
      width: doorWidth,
      height: 5500,
      x: 0, 
      y: 0,
      z: (buildingDepth / 2),
      rotationX: Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#999999'
    },
    {
      id: 'pointZero',
      width: 300,
      height: 200,
      x: -100, 
      y: -10, 
      z: -100,
      rotationX: (Math.PI / 2),
      rotationY: 0,
      obstruction: false,
      interaction: true,
      innerHTML: `
        <div style="position: absolute; left: 0px; top: 0px; width: 300px; height: 200px;">
          <svg style="position: absolute; left: 0px; top: 0px; width: 300px; height: 200px;">
            <line x1="0" y1="100" x2="200" y2="100" style="stroke:#ff0000; stroke-width:10;" />
            <line x1="100" y1="0" x2="100" y2="200" style="stroke:#0000ff; stroke-width:10;" />
            <text x="120" y="180" font-size="70" fill="#000000">0,0,0</text>
          </svg>
        </div>
      `
    },
    {
      id: 'axisX',
      width: 500,
      height: 200,
      x: 0, 
      y: ((-(wallHeight / 2)) + 200) - 100, 
      z: 0,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: true,
      innerHTML: `
        <div style="position: absolute; left: 0px; top: 0px; width: 500px; height: 200px;">
          <svg style="position: absolute; left: 0px; top: 0px; width: 500px; height: 200px;">
            <line x1="0" y1="100" x2="404" y2="100" style="stroke:#ff0000; stroke-width:10;" />
            <line x1="400" y1="100" x2="360" y2="60" style="stroke:#ff0000; stroke-width:10;" />
            <line x1="400" y1="100" x2="360" y2="140" style="stroke:#ff0000; stroke-width:10;" />
            <text x="420" y="135" font-size="100" fill="#ff0000">X</text>
          </svg>
        </div>
      `
    },
    {
      id: 'axisY',
      width: 200,
      height: 500,
      x: -100, 
      y: ((-(wallHeight / 2)) + 200),
      z: 0,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: true,
      innerHTML: `
        <div style="position: absolute; left: 0px; top: 0px; width: 200px; height: 500px;">
          <svg style="position: absolute; left: 0px; top: 0px; width: 200px; height: 500px;">
            <line x1="100" y1="0" x2="100" y2="324" style="stroke:#00ff00; stroke-width:10;" />
            <line x1="100" y1="320" x2="60" y2="280" style="stroke:#00ff00; stroke-width:10;" />
            <line x1="100" y1="320" x2="140" y2="280" style="stroke:#00ff00; stroke-width:10;" />
            <text x="67" y="420" font-size="100" fill="#00ff00">Y</text>
          </svg>
        </div>
      `
    },
    {
      id: 'axisZ',
      width: 500,
      height: 200,
      x: 0, 
      y: ((-(wallHeight / 2)) + 200) - 100, 
      z: 500,
      rotationX: 0,
      rotationY: (Math.PI / 2),
      obstruction: false,
      interaction: true,
      innerHTML: `
        <div style="position: absolute; left: 0px; top: 0px; width: 500px; height: 200px;">
          <svg style="position: absolute; left: 0px; top: 0px; width: 500px; height: 200px;">
            <line x1="96" y1="100" x2="500" y2="100" style="stroke:#0000ff; stroke-width:10;" />
            <line x1="100" y1="100" x2="136" y2="60" style="stroke:#0000ff; stroke-width:10;" />
            <line x1="100" y1="100" x2="136" y2="140" style="stroke:#0000ff; stroke-width:10;" />
            <text x="0" y="135" font-size="100" fill="#0000ff">Z</text>
          </svg>
        </div>
      `
    },
    {
      id: 'floor',
      width: buildingWidth,
      height: buildingDepth,
      x: -(buildingWidth / 2), 
      y: 0,
      z: -(buildingDepth / 2),
      rotationX: Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#999999'
    },
    {
      id: 'wallBack',
      width: buildingWidth,
      height: wallHeight,
      x: -(buildingWidth / 2), 
      y: -wallHeight, 
      z: -(buildingDepth / 2),
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#e0e0e0'
    },
    {
      id: 'wallLeft',
      width: buildingDepth,
      height: wallHeight,
      x: -(buildingWidth / 2), 
      y: -wallHeight, 
      z: -(buildingDepth / 2),
      rotationX: 0,
      rotationY: -Math.PI / 2,
      obstruction: true,
      backgroundColor: '#d3d3d3'
    },
    {
      id: 'wallRight',
      width: buildingDepth,
      height: wallHeight,
      x: (buildingWidth / 2), 
      y: -wallHeight, 
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: Math.PI / 2,
      obstruction: true,
      backgroundColor: '#d3d3d3'
    },
    {
      id: 'wallFrontLeft',
      width: (buildingWidth / 2),
      height: wallHeight,
      x: -(buildingWidth / 2), 
      y: -wallHeight, 
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#cccccc'
    },
    {
      id: 'wallFrontRight',
      width: ((buildingWidth / 2) - doorWidth),
      height: wallHeight,
      x: doorWidth,
      y: -wallHeight,
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#cccccc'
    },
    {
      id: 'wallEntranceLeft',
      width: 800,
      height: wallHeight,
      x: 0, 
      y: -wallHeight, 
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: (Math.PI / 2),
      obstruction: true,
      backgroundColor: '#a0a0a0'
    },
    {
      id: 'wallEntranceRight',
      width: 800,
      height: wallHeight,
      x: doorWidth, 
      y: -wallHeight, 
      z: (buildingDepth / 2) - 800,
      rotationX: 0,
      rotationY: -(Math.PI / 2),
      obstruction: true,
      backgroundColor: '#a0a0a0'
    },
    {
      id: 'wallInsideLeft',
      width: (buildingWidth / 2),
      height: wallHeight,
      x: 0, 
      y: -wallHeight, 
      z: (buildingDepth / 2) - 800,
      rotationX: 0,
      rotationY: -Math.PI,
      obstruction: true,
      backgroundColor: '#e0e0e0'
    },
    {
      id: 'wallInsideRight',
      width: ((buildingWidth / 2) - doorWidth),
      height: wallHeight,
      x: (buildingWidth / 2), 
      y: -wallHeight, 
      z: (buildingDepth / 2) - 800,
      rotationX: 0,
      rotationY: -Math.PI,
      obstruction: true,
      backgroundColor: '#e0e0e0'
    },    
    {
      id: 'door',
      title: 'open/close door',
      width: doorWidth,
      height: wallHeight,
      x: 0, 
      y: -wallHeight, 
      z: (buildingDepth / 2) - 600,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#0099ff',
      opacity: 0.3,
      innerHTML: `
        <svg style="position: absolute; left: 20px; top: ${((wallHeight/2) + 200)}px; width: 160px; height: 160px;">
          <circle cx="80" cy="80" r="70" stroke="#ffffff" stroke-width="20" fill="none" />
          <line x1="80" y1="40" x2="80" y2="120" style="stroke:#ffffff; stroke-width:20;" />
        </svg>
      `,
      userData: {
        opening: false,
        closing: false,
        opened: false,
        waitAnimate: false
      },
      click(html3d, panel) {
        if ((panel.userData.opening !== true) && (panel.userData.closing !== true)) {
          if (panel.userData.opened !== true) {
            panel.userData.opening = true;
          } else {
            panel.userData.closing = true;
          }
          panel.userData.waitAnimate = true;
          initAudioContext().then(() => {
            {
              const gainNode1 = audioCtx.createGain();
              gainNode1.connect(audioCtxMainGain);
              gainNode1.gain.setValueAtTime(0.30, audioCtx.currentTime);
              const oscillator1 = audioCtx.createOscillator();
              oscillator1.type = 'triangle';
              oscillator1.frequency.setValueAtTime(201, audioCtx.currentTime);
              oscillator1.start(audioCtx.currentTime);
              oscillator1.stop(audioCtx.currentTime + 0.6);
              oscillator1.connect(gainNode1);
            }
            {
              const gainNode2 = audioCtx.createGain();
              gainNode2.connect(audioCtxMainGain);
              gainNode2.gain.setValueAtTime(0.10, audioCtx.currentTime);
              const oscillator2 = audioCtx.createOscillator();
              oscillator2.type = 'square';
              oscillator2.frequency.setValueAtTime(61, audioCtx.currentTime);
              oscillator2.connect(gainNode2);
              oscillator2.start(audioCtx.currentTime);
              oscillator2.stop(audioCtx.currentTime + 0.6);
            }
            {
              const gainNode3 = audioCtx.createGain();
              gainNode3.connect(audioCtxMainGain);
              gainNode3.gain.setValueAtTime(0.02, audioCtx.currentTime);
              const oscillator3 = audioCtx.createOscillator();
              oscillator3.type = 'sine';
              oscillator3.frequency.setValueAtTime(3000, audioCtx.currentTime);
              oscillator3.connect(gainNode3);
              oscillator3.start(audioCtx.currentTime);
              oscillator3.stop(audioCtx.currentTime + 0.6);
            }
            panel.userData.waitAnimate = false;
          });
        }
      },
      animate(html3d, panel) {
        if (panel.userData.waitAnimate === true) {
          return;
        }
        if (panel.userData.opening === true) {
          const doorSpeed = 40;
          panel.x += doorSpeed;
          if (panel.x > (doorWidth - 200)) {
            panel.x = doorWidth - 200;
            panel.userData.opening = false;
            panel.userData.opened = true;
          }
          panel.updateWorldMatrix();
          html3d.requestRender = true;
        } else if (panel.userData.closing === true) {
          const doorSpeed = 40;
          panel.x -= doorSpeed;
          if (panel.x < 0) {
            panel.x = 0
            panel.userData.closing = false;
            panel.userData.opened = false;
          }
          panel.updateWorldMatrix();
          html3d.requestRender = true;
        }
      }
    },
    {
      id: 'ceilingFront',
      width: buildingWidth,
      height: (buildingDepth - 3000),
      x: -(buildingWidth / 2),
      y: -wallHeight,
      z: (buildingDepth / 2),
      rotationX: -Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#6C6C6C'
    },
    {
      id: 'ceilingBack',
      width: (buildingWidth - 3000),
      height: 3000,
      x: (-buildingWidth / 2) + 3000,
      y: -wallHeight,
      z: (-buildingDepth / 2) + 3000,
      rotationX: -Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#6C6C6C'
    },
    {
      id: 'firstFloorFront',
      width: buildingWidth,
      height: (buildingDepth - 3000),
      x: -(buildingWidth / 2),
      y: -(wallHeight + floorDepth),
      z: (buildingDepth / 2),
      rotationX: -Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#fefefe'
    },
    {
      id: 'firstFloorBack',
      width: (buildingWidth - 3000),
      height: 3000,
      x: (-buildingWidth / 2) + 3000,
      y: -(wallHeight + floorDepth),
      z: (-buildingDepth / 2) + 3000,
      rotationX: -Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#fefefe'
    },
    {
      id: 'firstFloorPanelFront',
      width: 3000,
      height: floorDepth,
      x: -(buildingWidth / 2),
      y: -(wallHeight + floorDepth),
      z: (-buildingDepth / 2) + 3000,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#e0e0e0'
    },
    {
      id: 'firstFloorPanelRight',
      width: 3000,
      height: floorDepth,
      x: (-buildingWidth / 2) + 3000,
      y: -(wallHeight + floorDepth),
      z: (-buildingDepth / 2),
      rotationX: 0,
      rotationY: -Math.PI / 2,
      obstruction: false,
      backgroundColor: '#d3d3d3'
    },
    {
      id: 'wallBackTop',
      width: buildingWidth,
      height: (wallHeight + floorDepth),
      x: -(buildingWidth / 2),
      y: -(wallHeight + floorDepth + wallHeight), 
      z: -(buildingDepth / 2),
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#e0e0e0'
    },
    {
      id: 'wallLeftTop',
      width: buildingDepth,
      height: (wallHeight + floorDepth),
      x: -(buildingWidth / 2), 
      y: -(wallHeight + floorDepth + wallHeight), 
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: Math.PI / 2,
      obstruction: true,
      backgroundColor: '#d3d3d3'
    },
    {
      id: 'wallRightTop',
      width: buildingDepth,
      height: (wallHeight + floorDepth),
      x: (buildingWidth / 2), 
      y: -(wallHeight + floorDepth + wallHeight), 
      z: -(buildingDepth / 2),
      rotationX: 0,
      rotationY: -Math.PI / 2,
      obstruction: true,
      backgroundColor: '#d3d3d3'
    },
    {
      id: 'wallFrontTopLeft',
      width: ((buildingWidth / 2) - firstFloorWindowWidth) / 2,
      height: (wallHeight + floorDepth),
      x: -(buildingWidth / 2),
      y: -(wallHeight + floorDepth + wallHeight),
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#cccccc'
    },
    {
      id: 'wallFrontTopLeftTop',
      width: firstFloorWindowWidth,
      height: (wallHeight - firstFloorWindowHeight) / 2,
      x: (-buildingWidth / 2) + (((buildingWidth / 2) - firstFloorWindowWidth) / 2),
      y: -(wallHeight + floorDepth + wallHeight),
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#cccccc'
    },
    {
      id: 'wallFrontTopLeftBottom',
      width: firstFloorWindowWidth,
      height: ((wallHeight - firstFloorWindowHeight) / 2) + firstFloorWindowHeight,
      x: (-buildingWidth / 2) + (((buildingWidth / 2) - firstFloorWindowWidth) / 2),
      y: -(wallHeight + floorDepth + ((wallHeight - firstFloorWindowHeight) / 2)),
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#cccccc'
    },
    {
      id: 'wallFrontTopRight',
      width: ((buildingWidth / 2) + (((buildingWidth / 2) - firstFloorWindowWidth) / 2)),
      height: (wallHeight + floorDepth),
      x: -(((buildingWidth / 2) - firstFloorWindowWidth) / 2),
      y: -(wallHeight + floorDepth + wallHeight),
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#cccccc'
    },
    {
      id: 'wallFrontTopLeftInside',
      width: (((buildingWidth / 2) - firstFloorWindowWidth) / 2),
      height: wallHeight,
      x: -(buildingWidth / 2),
      y: -(wallHeight + floorDepth + wallHeight),
      z: (buildingDepth / 2) - firstFloorWallDepth,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#eeeeee'
    },
    {
      id: 'wallFrontTopLeftTopInside',
      width: firstFloorWindowWidth,
      height: (wallHeight - firstFloorWindowHeight) / 2,
      x: (-buildingWidth / 2) + (((buildingWidth / 2) - firstFloorWindowWidth) / 2),
      y: -(wallHeight + floorDepth + wallHeight),
      z: (buildingDepth / 2) - firstFloorWallDepth,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#eeeeee'
    },
    {
      id: 'wallFrontTopLeftBottomInside',
      width: firstFloorWindowWidth,
      height: ((wallHeight - firstFloorWindowHeight) / 2),
      x: (-buildingWidth / 2) + (((buildingWidth / 2) - firstFloorWindowWidth) / 2),
      y: -(wallHeight + floorDepth + ((wallHeight - firstFloorWindowHeight) / 2)),
      z: (buildingDepth / 2) - firstFloorWallDepth,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#eeeeee'
    },
    {
      id: 'wallFrontTopRightInside',
      width: ((buildingWidth / 2) + (((buildingWidth / 2) - firstFloorWindowWidth) / 2)),
      height: wallHeight,
      x: -(((buildingWidth / 2) - firstFloorWindowWidth) / 2),
      y: -(wallHeight + floorDepth + wallHeight),
      z: (buildingDepth / 2) - firstFloorWallDepth,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#eeeeee'
    },
    {
      id: 'windowInnerWallLeft',
      width: firstFloorWallDepth,
      height: firstFloorWindowHeight,
      x: (-buildingWidth / 2) + (((buildingWidth / 2) - firstFloorWindowWidth) / 2),
      y: (-(wallHeight + floorDepth + wallHeight)) + ((wallHeight - firstFloorWindowHeight) / 2),
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: Math.PI / 2,
      obstruction: false,
      backgroundColor: '#a0a0a0'
    },
    {
      id: 'windowInnerWallRight',
      width: firstFloorWallDepth,
      height: firstFloorWindowHeight,
      x: (-buildingWidth / 2) + (((buildingWidth / 2) - firstFloorWindowWidth) / 2) + firstFloorWindowWidth,
      y: (-(wallHeight + floorDepth + wallHeight)) + ((wallHeight - firstFloorWindowHeight) / 2),
      z: (buildingDepth / 2),
      rotationX: 0,
      rotationY: Math.PI / 2,
      obstruction: false,
      backgroundColor: '#a0a0a0'
    },
    {
      id: 'windowInnerWallTop',
      width: firstFloorWindowWidth,
      height: firstFloorWallDepth,
      x: (-buildingWidth / 2) + (((buildingWidth / 2) - firstFloorWindowWidth) / 2),
      y: (-(wallHeight + floorDepth + wallHeight)) + ((wallHeight - firstFloorWindowHeight) / 2),
      z: (buildingDepth / 2),
      rotationX: -Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#bbbbbb'
    },
    {
      id: 'windowInnerWallBottom',
      width: firstFloorWindowWidth,
      height: firstFloorWallDepth,
      x: (-buildingWidth / 2) + (((buildingWidth / 2) - firstFloorWindowWidth) / 2),
      y: (-(wallHeight + floorDepth)) - ((wallHeight - firstFloorWindowHeight) / 2),
      z: (buildingDepth / 2),
      rotationX: -Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#bbbbbb'
    },
    {
      id: 'roof',
      width: buildingWidth,
      height: buildingDepth,
      x: -(buildingWidth / 2),
      y: -(wallHeight + floorDepth + wallHeight),
      z: -(buildingDepth / 2),
      rotationX: Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      backgroundColor: '#aaaaaa'
    },
    {
      id: 'elevator',
      width: 3000,
      height: 3000,
      x: (-buildingWidth / 2),
      y: -10,
      z: (-buildingDepth / 2),
      rotationX: Math.PI / 2,
      rotationY: 0,
      obstruction: true,
      backgroundColor: '#0099ff',
      opacity: 0.3,
      userData: {
        goingUp: false,
        goingDown: false,
        isUp: false,
        animateCameraOnElevator: false,
        waitAnimate: false
      },
      animate(html3d, panel) {
        const elevatorObject = panel;
        if (elevatorObject.userData.waitAnimate === true) {
          return;
        }
        if (elevatorObject.userData.goingUp === true) {
          const elevatorSpeed = 20;
          elevatorObject.y -= elevatorSpeed;
          if (elevatorObject.y < (-(wallHeight + floorDepth))) {
            elevatorObject.y = -(wallHeight + floorDepth);
            elevatorObject.userData.goingUp = false;
            elevatorObject.userData.isUp = true;
          }
          elevatorObject.updateWorldMatrix();
          if (elevatorObject.userData.animateCameraOnElevator === true) {
            html3d.camera.y = elevatorObject.y - cameraHeight;
            html3d.camera.updateWorldMatrix();
          }
          html3d.requestRender = true;
        } else if (elevatorObject.userData.goingDown === true) {
          const elevatorSpeed = 20;
          elevatorObject.y += elevatorSpeed;
          if (elevatorObject.y > -10) {
            elevatorObject.y = -10;
            elevatorObject.userData.goingDown = false;
            elevatorObject.userData.isUp = false;
          }
          elevatorObject.updateWorldMatrix();
          if (elevatorObject.userData.animateCameraOnElevator === true) {
            html3d.camera.y = elevatorObject.y - cameraHeight;
            html3d.camera.updateWorldMatrix();
          }
          html3d.requestRender = true;
        } else {
          if ((html3d.camera.x > (-buildingWidth / 2)) && (html3d.camera.x < (-buildingWidth / 2) + 3000) &&
              (html3d.camera.z > (-buildingDepth / 2)) && (html3d.camera.z < (-buildingDepth / 2) + 3000)) {
            if (elevatorObject.userData.isUp !== true) {
              if (html3d.camera.y < -cameraHeight) {
                html3d.camera.y += 50;
                if (html3d.camera.y > -cameraHeight) {
                  html3d.camera.y = -cameraHeight;
                }
                html3d.camera.updateWorldMatrix();
                html3d.requestRender = true;
              }
            }
          }
        }
      }
    },
    {
      id: 'groundFloorElevatorControls',
      title: 'move elevator up or down',
      width: 300,
      height: 300,
      x: (-buildingWidth / 2) + 2000,
      y: (-wallHeight / 2),
      z: (-buildingDepth / 2) + 3000,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#0099ff',
      opacity: 0.3,
      innerHTML: `
        <svg style="position: absolute; left: 50px; top: 50px; width: 200px; height: 200px;">
          <circle cx="100" cy="100" r="80" stroke="#ffffff" stroke-width="10" fill="none" />
          <line x1="100" y1="40" x2="100" y2="160" style="stroke:#ffffff; stroke-width:10;" />
        </svg>
      `,
      click(html3d, panel) {
        const elevatorObject = html3d.panels.find((so) => so.id === 'elevator');
        if ((html3d.camera.x > (-buildingWidth / 2)) && (html3d.camera.x < (-buildingWidth / 2) + 3000) &&
            (html3d.camera.z > (-buildingDepth / 2)) && (html3d.camera.z < (-buildingDepth / 2) + 3000)) {
          elevatorObject.userData.animateCameraOnElevator = true;
        } else {
          elevatorObject.userData.animateCameraOnElevator = false;
        }
        if ((elevatorObject.userData.goingUp !== true) && (elevatorObject.userData.goingDown !== true)) {
          if (elevatorObject.userData.isUp !== true) {
            elevatorObject.userData.goingUp = true;
          } else {
            elevatorObject.userData.goingDown = true;
          }
          elevatorObject.userData.waitAnimate = true;
          initAudioContext().then(() => {
            {
              const gainNode1 = audioCtx.createGain();
              gainNode1.connect(audioCtxMainGain);
              gainNode1.gain.setValueAtTime(0.30, audioCtx.currentTime);
              const oscillator1 = audioCtx.createOscillator();
              oscillator1.type = 'triangle';
              oscillator1.frequency.setValueAtTime(201, audioCtx.currentTime);
              oscillator1.start(audioCtx.currentTime);
              oscillator1.stop(audioCtx.currentTime + 1.7);
              oscillator1.connect(gainNode1);
            }
            {
              const gainNode2 = audioCtx.createGain();
              gainNode2.connect(audioCtxMainGain);
              gainNode2.gain.setValueAtTime(0.10, audioCtx.currentTime);
              const oscillator2 = audioCtx.createOscillator();
              oscillator2.type = 'sawtooth';
              oscillator2.frequency.setValueAtTime(61, audioCtx.currentTime);
              oscillator2.connect(gainNode2);
              oscillator2.start(audioCtx.currentTime);
              oscillator2.stop(audioCtx.currentTime + 1.7);
            }
            {
              const gainNode3 = audioCtx.createGain();
              gainNode3.connect(audioCtxMainGain);
              gainNode3.gain.setValueAtTime(0.02, audioCtx.currentTime);
              const oscillator3 = audioCtx.createOscillator();
              oscillator3.type = 'sine';
              oscillator3.frequency.setValueAtTime(1000, audioCtx.currentTime);
              oscillator3.connect(gainNode3);
              oscillator3.start(audioCtx.currentTime);
              oscillator3.stop(audioCtx.currentTime + 1.7);
            }
            elevatorObject.userData.waitAnimate = false;
          });
        }
      }
    },
    {
      id: 'groundFloorElevatorControlsStand',
      width: 300,
      height: ((wallHeight / 2) - 300),
      x: (-buildingWidth / 2) + 2000,
      y: -((wallHeight / 2) - 300),
      z: (-buildingDepth / 2) + 3000,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: false,
      backgroundColor: '#444444'
    },
    {
      id: 'firstFloorElevatorControls',
      title: 'move elevator up or down',
      width: 300,
      height: 300,
      x: (-buildingWidth / 2) + 2000,
      y: (-(wallHeight + floorDepth)) + (-wallHeight / 2),
      z: (-buildingDepth / 2) + 3000,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#0099ff',
      opacity: 0.3,
      innerHTML: `
        <svg style="position: absolute; left: 50px; top: 50px; width: 200px; height: 200px;">
          <circle cx="100" cy="100" r="80" stroke="#ffffff" stroke-width="10" fill="none" />
          <line x1="100" y1="40" x2="100" y2="160" style="stroke:#ffffff; stroke-width:10;" />
        </svg>
      `,
      click(html3d, panel) {
        const elevatorObject = html3d.panels.find((so) => so.id === 'elevator');
        if ((html3d.camera.x > (-buildingWidth / 2)) && (html3d.camera.x < (-buildingWidth / 2) + 3000) &&
            (html3d.camera.z > (-buildingDepth / 2)) && (html3d.camera.z < (-buildingDepth / 2) + 3000)) {
          elevatorObject.userData.animateCameraOnElevator = true;
        } else {
          elevatorObject.userData.animateCameraOnElevator = false;
        }
        if ((elevatorObject.userData.goingUp !== true) && (elevatorObject.userData.goingDown !== true)) {
          if (elevatorObject.userData.isUp !== true) {
            elevatorObject.userData.goingUp = true;
          } else {
            elevatorObject.userData.goingDown = true;
          }
          elevatorObject.userData.waitAnimate = true;
          initAudioContext().then(() => {
            {
              const gainNode1 = audioCtx.createGain();
              gainNode1.connect(audioCtxMainGain);
              gainNode1.gain.setValueAtTime(0.30, audioCtx.currentTime);
              const oscillator1 = audioCtx.createOscillator();
              oscillator1.type = 'triangle';
              oscillator1.frequency.setValueAtTime(201, audioCtx.currentTime);
              oscillator1.start(audioCtx.currentTime);
              oscillator1.stop(audioCtx.currentTime + 1.7);
              oscillator1.connect(gainNode1);
            }
            {
              const gainNode2 = audioCtx.createGain();
              gainNode2.connect(audioCtxMainGain);
              gainNode2.gain.setValueAtTime(0.10, audioCtx.currentTime);
              const oscillator2 = audioCtx.createOscillator();
              oscillator2.type = 'sawtooth';
              oscillator2.frequency.setValueAtTime(61, audioCtx.currentTime);
              oscillator2.connect(gainNode2);
              oscillator2.start(audioCtx.currentTime);
              oscillator2.stop(audioCtx.currentTime + 1.7);
            }
            {
              const gainNode3 = audioCtx.createGain();
              gainNode3.connect(audioCtxMainGain);
              gainNode3.gain.setValueAtTime(0.02, audioCtx.currentTime);
              const oscillator3 = audioCtx.createOscillator();
              oscillator3.type = 'sine';
              oscillator3.frequency.setValueAtTime(1000, audioCtx.currentTime);
              oscillator3.connect(gainNode3);
              oscillator3.start(audioCtx.currentTime);
              oscillator3.stop(audioCtx.currentTime + 1.7);
            }
            elevatorObject.userData.waitAnimate = false;
          });
        }
      }
    },
    {
      id: 'firstFloorElevatorControlsStand',
      width: 300,
      height: ((wallHeight / 2) - 300),
      x: (-buildingWidth / 2) + 2000,
      y: ((-(wallHeight + floorDepth)) - ((wallHeight / 2) - 300)),
      z: (-buildingDepth / 2) + 3000,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: false,
      backgroundColor: '#444444'
    },
    {
      id: 'testPanelControllerStand',
      width: 640,
      height: ((wallHeight / 2) - 100),
      x: 600,
      y: -((wallHeight / 2) - 100),
      z: 10,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#444444'
    },
    {
      id: 'testPanelControllerPanel',
      width: 640,
      height: 370,
      x: 600,
      y: -((wallHeight / 2) - 100),
      z: 10,
      rotationX: ((Math.PI / 2) * 0.3),
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#222222',
      innerHTML: `
        <div id="testPanelControllerPanel_header" style="position: absolute; left: 170px; top: 10px; width: 400px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 18px;">
          TEST PANEL CONTROLLER
        </div>
        <div style="position: absolute; left: 0px; top: 55px; width: 130px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px; text-align: right;">
          width
        </div>
          <input id="testPanelControllerPanel_width" type="range" min="10" max="1000" step="10" style="position: absolute; left: 170px; top: 55px; width: 250px; height: 18px; overflow: hidden; appearance: none; accent-color: #ff0000; background-color: #ffffff;">
          <div id="testPanelControllerPanel_width_value" style="position: absolute; left: 450px; top: 55px; width: 150px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px;">
            width value
          </div>
        <div style="position: absolute; left: 0px; top: 90px; width: 130px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px; text-align: right;">
          height
        </div>
          <input id="testPanelControllerPanel_height" type="range" min="10" max="1000" step="10" style="position: absolute; left: 170px; top: 90px; width: 250px; height: 18px; overflow: hidden; appearance: none; accent-color: #00ff00; background-color: #ffffff;">
          <div id="testPanelControllerPanel_height_value" style="position: absolute; left: 450px; top: 90px; width: 150px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px;">
            height value
          </div>
        <div style="position: absolute; left: 0px; top: 125px; width: 130px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px; text-align: right;">
          x
        </div>
          <input id="testPanelControllerPanel_x" type="range" min="-3000" max="3000" step="10" style="position: absolute; left: 170px; top: 125px; width: 250px; height: 18px; overflow: hidden; appearance: none; accent-color: #ff0000; background-color: #ffffff;">
          <div id="testPanelControllerPanel_x_value" style="position: absolute; left: 450px; top: 125px; width: 150px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px;">
            x value
          </div>
          <button id="testPanelControllerPanel_x_value_reset" title="set to 0" style="position: absolute; left: 550px; top: 125px; width: 50px; height: 22px; color: #000000; font-size: 12px; cursor: pointer;">
            reset
          </button>
        <div style="position: absolute; left: 0px; top: 160px; width: 130px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px; text-align: right;">
          y
        </div>
          <input id="testPanelControllerPanel_y" type="range" min="-3000" max="3000" step="10" style="position: absolute; left: 170px; top: 160px; width: 250px; height: 18px; overflow: hidden; appearance: none; accent-color: #00ff00; background-color: #ffffff;">
          <div id="testPanelControllerPanel_y_value" style="position: absolute; left: 450px; top: 160px; width: 150px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px;">
            y value
          </div>
          <button id="testPanelControllerPanel_y_value_reset" title="set to 0" style="position: absolute; left: 550px; top: 160px; width: 50px; height: 22px; color: #000000; font-size: 12px; cursor: pointer;">
            reset
          </button>
        <div style="position: absolute; left: 0px; top: 195px; width: 130px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px; text-align: right;">
          z
        </div>
          <input id="testPanelControllerPanel_z" type="range" min="-3000" max="3000" step="10" style="position: absolute; left: 170px; top: 195px; width: 250px; height: 18px; overflow: hidden; appearance: none; accent-color: #0000ff; background-color: #ffffff;">
          <div id="testPanelControllerPanel_z_value" style="position: absolute; left: 450px; top: 195px; width: 150px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px;">
            z value
          </div>
          <button id="testPanelControllerPanel_z_value_reset" title="set to 0" style="position: absolute; left: 550px; top: 195px; width: 50px; height: 22px; color: #000000; font-size: 12px; cursor: pointer;">
            reset
          </button>
        <div style="position: absolute; left: 0px; top: 230px; width: 130px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px; text-align: right;">
          rotation x
        </div>
          <input id="testPanelControllerPanel_rotationXdegrees" type="range" min="-180" max="180" step="1" style="position: absolute; left: 170px; top: 230px; width: 250px; height: 18px; overflow: hidden; appearance: none; accent-color: #ff0000; background-color: #ffffff;">
          <div id="testPanelControllerPanel_rotationXdegrees_valueRadians" style="position: absolute; left: 450px; top: 230px; width: 150px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px;">
            rotation x value
          </div>
          <button id="testPanelControllerPanel_rotationXdegrees_valueRadians_reset" title="set to 0" style="position: absolute; left: 550px; top: 230px; width: 50px; height: 22px; color: #000000; font-size: 12px; cursor: pointer;">
            reset
          </button>
        <div style="position: absolute; left: 0px; top: 265px; width: 130px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px; text-align: right;">
          rotation y
        </div>
          <input id="testPanelControllerPanel_rotationYdegrees" type="range" min="-180" max="180" step="1" style="position: absolute; left: 170px; top: 265px; width: 250px; height: 18px; overflow: hidden; appearance: none; accent-color: #00ff00; background-color: #ffffff;">
          <div id="testPanelControllerPanel_rotationYdegrees_valueRadians" style="position: absolute; left: 450px; top: 265px; width: 150px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px;">
            rotation y value
          </div>
          <button id="testPanelControllerPanel_rotationYdegrees_valueRadians_reset" title="set to 0" style="position: absolute; left: 550px; top: 265px; width: 50px; height: 22px; color: #000000; font-size: 12px; cursor: pointer;">
            reset
          </button>
        <div style="position: absolute; left: 0px; top: 300px; width: 130px; height: 22px; line-height: 22px; color: #ffffff; overflow: hidden; white-space: nowrap; font-size: 16px; text-align: right;">
          anchor center
        </div>
          <div id="testPanelControllerPanel_anchorCenter" style="position: absolute; left: 170px; top: 300px; width: 22px; height: 22px; background-color: #ffffff; cursor: pointer;">
            <svg id="testPanelControllerPanel_anchorCenter_check" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="position: absolute; left: 0px; top: 0px; width: 22px; height: 22px;">
              <path fill="#000000" d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z" />
            </svg>
          </div>
      `,
      init(html3d, panel) {
        const testPanel = html3d.panels.find((so) => so.id === 'testPanel');
        const testPanelContainer = document.getElementById('testPanelContainer');
        const testPanelContent = document.getElementById('testPanelContent');
        const widthInput = document.getElementById('testPanelControllerPanel_width');
        const widthValue = document.getElementById('testPanelControllerPanel_width_value');
        const heightInput = document.getElementById('testPanelControllerPanel_height');
        const heightValue = document.getElementById('testPanelControllerPanel_height_value');
        const xInput = document.getElementById('testPanelControllerPanel_x');
        const xValue = document.getElementById('testPanelControllerPanel_x_value');
        const xValueReset = document.getElementById('testPanelControllerPanel_x_value_reset');
        const yInput = document.getElementById('testPanelControllerPanel_y');
        const yValue = document.getElementById('testPanelControllerPanel_y_value');
        const yValueReset = document.getElementById('testPanelControllerPanel_y_value_reset');
        const zInput = document.getElementById('testPanelControllerPanel_z');
        const zValue = document.getElementById('testPanelControllerPanel_z_value');
        const zValueReset = document.getElementById('testPanelControllerPanel_z_value_reset');
        const rotationXInput = document.getElementById('testPanelControllerPanel_rotationXdegrees');
        const rotationXValue = document.getElementById('testPanelControllerPanel_rotationXdegrees_valueRadians');
        const rotationXValueReset = document.getElementById('testPanelControllerPanel_rotationXdegrees_valueRadians_reset');
        const rotationYInput = document.getElementById('testPanelControllerPanel_rotationYdegrees');
        const rotationYValue = document.getElementById('testPanelControllerPanel_rotationYdegrees_valueRadians');
        const rotationYValueReset = document.getElementById('testPanelControllerPanel_rotationYdegrees_valueRadians_reset');
        const anchorCenter = document.getElementById('testPanelControllerPanel_anchorCenter');
        const anchorCenterCheck = document.getElementById('testPanelControllerPanel_anchorCenter_check');
        widthInput.addEventListener('input', () => {
          testPanel.width = parseInt(widthInput.value, 10);
          testPanel.element.style.width = `${testPanel.width}px`;
          testPanelContainer.style.width = `${testPanel.width - 20}px`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          widthValue.textContent = `${testPanel.width} px`;
        });
        heightInput.addEventListener('input', () => {
          testPanel.height = parseInt(heightInput.value, 10);
          testPanel.element.style.height = `${testPanel.height}px`;
          testPanelContainer.style.height = `${testPanel.height - 20}px`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          heightValue.textContent = `${testPanel.height} px`;
        });
        xInput.addEventListener('input', () => {
          testPanel.x = parseInt(xInput.value, 10);
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          xValue.textContent = `${testPanel.x} px`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          xValueReset.style.visibility = (testPanel.x === 0) ? 'hidden' : 'visible';
        });
        xValueReset.addEventListener('click', () => {
          testPanel.x = 0;
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          xInput.value = testPanel.x;
          xValue.textContent = `${testPanel.x} px`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          xValueReset.style.visibility = 'hidden';
        });
        yInput.addEventListener('input', () => {
          testPanel.y = parseInt(yInput.value, 10);
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          yValue.textContent = `${testPanel.y} px`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          yValueReset.style.visibility = (testPanel.y === 0) ? 'hidden' : 'visible';
        });
        yValueReset.addEventListener('click', () => {
          testPanel.y = 0;
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          yInput.value = testPanel.y;
          yValue.textContent = `${testPanel.y} px`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          yValueReset.style.visibility = 'hidden';
        });
        zInput.addEventListener('input', () => {
          testPanel.z = parseInt(zInput.value, 10);
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          zValue.textContent = `${testPanel.z} px`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          zValueReset.style.visibility = (testPanel.z === 0) ? 'hidden' : 'visible';
        });
        zValueReset.addEventListener('click', () => {
          testPanel.z = 0;
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          zInput.value = testPanel.z;
          zValue.textContent = `${testPanel.z} px`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          zValueReset.style.visibility = 'hidden';
        });
        rotationXInput.addEventListener('input', () => {
          const rotationX = parseFloat(rotationXInput.value);
          testPanel.rotationX = rotationX * (Math.PI / 180);
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          rotationXValue.textContent = `${testPanel.rotationX.toFixed(3)} rad`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          rotationXValueReset.style.visibility = (testPanel.rotationX === 0) ? 'hidden' : 'visible';
        });
        rotationXValueReset.addEventListener('click', () => {
          testPanel.rotationX = 0;
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          rotationXInput.value = (testPanel.rotationX * (180 / Math.PI)).toFixed(3);
          rotationXValue.textContent = `${testPanel.rotationX.toFixed(3)} rad`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          rotationXValueReset.style.visibility = 'hidden';
        });
        rotationYInput.addEventListener('input', () => {
          const rotationY = parseFloat(rotationYInput.value);
          testPanel.rotationY = rotationY * (Math.PI / 180);
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          rotationYValue.textContent = `${testPanel.rotationY.toFixed(3)} rad`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          rotationYValueReset.style.visibility = (testPanel.rotationY === 0) ? 'hidden' : 'visible';
        });
        rotationYValueReset.addEventListener('click', () => {
          testPanel.rotationY = 0;
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          rotationYInput.value = (testPanel.rotationY * (180 / Math.PI)).toFixed(3);
          rotationYValue.textContent = `${testPanel.rotationY.toFixed(3)} rad`;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          rotationYValueReset.style.visibility = 'hidden';
        });
        anchorCenter.addEventListener('click', () => {
          testPanel.anchorCenter = !testPanel.anchorCenter;
          testPanel.updateWorldMatrix();
          html3d.requestRender = true;
          testPanelContent.innerHTML = JSON.stringify(testPanel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          if (testPanel.anchorCenter === true) {
            anchorCenterCheck.style.display = 'block';
          } else {
            anchorCenterCheck.style.display = 'none';
          }
        });
        widthInput.value = testPanel.width;
        widthValue.textContent = `${testPanel.width} px`;
        heightInput.value = testPanel.height;
        heightValue.textContent = `${testPanel.height} px`;
        xInput.value = testPanel.x;
        xValue.textContent = `${testPanel.x} px`;
        xValueReset.style.visibility = (testPanel.x === 0) ? 'hidden' : 'visible';
        yInput.value = testPanel.y;
        yValue.textContent = `${testPanel.y} px`;
        yValueReset.style.visibility = (testPanel.y === 0) ? 'hidden' : 'visible';
        zInput.value = testPanel.z;
        zValue.textContent = `${testPanel.z} px`;
        zValueReset.style.visibility = (testPanel.z === 0) ? 'hidden' : 'visible';
        rotationXInput.value = (testPanel.rotationX * (180 / Math.PI)).toFixed(3);
        rotationXValue.textContent = `${testPanel.rotationX.toFixed(3)} rad`;
        rotationXValueReset.style.visibility = (testPanel.rotationX === 0) ? 'hidden' : 'visible';
        rotationYInput.value = (testPanel.rotationY * (180 / Math.PI)).toFixed(3);
        rotationYValue.textContent = `${testPanel.rotationY.toFixed(3)} rad`;
        rotationYValueReset.style.visibility = (testPanel.rotationY === 0) ? 'hidden' : 'visible';
        if (testPanel.anchorCenter === true) {
          anchorCenterCheck.style.display = 'block';
        } else {
          anchorCenterCheck.style.display = 'none';
        }
      }
    },
    {
      id: 'testPanel',
      width: 600,
      height: 400,
      x: 0,
      y: -1250,
      z: 0,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: true,
      backgroundColor: '#ffffff',
      innerHTML: `
        <div id="testPanelContainer" style="position: absolute; left: 0px; top: 0px; width: 380px; height: 380px; border: 5px solid #000000; padding: 5px; background-color: #ffffff; color: #000000; font-size: 20px; font-family: monospace; white-space: nowrap; overflow: auto;">
          <pre id="testPanelContent" style="margin-block-start: 0;"></pre>
        </div>
      `,
      init(html3d, panel) {
        const testPanelContainer = document.getElementById('testPanelContainer');
        const testPanelContent = document.getElementById('testPanelContent');
        testPanelContainer.style.width = `${panel.width - 20}px`;
        testPanelContainer.style.height = `${panel.height - 20}px`;
        testPanelContent.innerHTML = JSON.stringify(panel.export(), null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
      },
    },
    {
      id: 'testPanelAxisX',
      relativeToId: 'testPanel',
      width: 100,
      height: 10,
      anchorCenter: true,
      x: 0,
      y: 0,
      z: 0,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: false,
      backgroundColor: '#ff0000'
    },
    {
      id: 'testPanelAxisY',
      relativeToId: 'testPanel',
      width: 10,
      height: 100,
      anchorCenter: true,
      x: 0,
      y: 0,
      z: 0,
      rotationX: 0,
      rotationY: Math.PI / 2,
      obstruction: false,
      interaction: false,
      backgroundColor: '#00ff00'
    },
    {
      id: 'testPanelAxisZ',
      relativeToId: 'testPanel',
      width: 10,
      height: 100,
      anchorCenter: true,
      x: 0,
      y: 0,
      z: 0,
      rotationX: Math.PI / 2,
      rotationY: 0,
      obstruction: false,
      interaction: false,
      backgroundColor: '#0000ff'
    },
    {
      id: 'arcadeCabinet',
      width: 1100,
      height: 1400,
      x: 3000,
      y: -1400,
      z: -2000,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#333333'
    },
    {
      id: 'arcadeCabinetFront',
      width: 1100,
      height: 1400,
      x: 3000,
      y: -1400,
      z: -2000,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#333333'
    },
    {
      id: 'arcadeCabinetBack',
      width: 1100,
      height: 1400,
      x: 3000,
      y: -1400,
      z: -2300,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#333333'
    },
    {
      id: 'arcadeCabinetLeft',
      width: 300,
      height: 1400,
      x: 3000,
      y: -1400,
      z: -2300,
      rotationX: 0,
      rotationY: -(Math.PI / 2),
      obstruction: true,
      interaction: true,
      backgroundColor: '#222222'
    },
    {
      id: 'arcadeCabinetRight',
      width: 300,
      height: 1400,
      x: 4100,
      y: -1400,
      z: -2300,
      rotationX: 0,
      rotationY: -(Math.PI / 2),
      obstruction: true,
      interaction: true,
      backgroundColor: '#222222'
    },
    {
      id: 'arcadeCabinetIframe',
      width: 1000,
      height: 600,
      x: 3050,
      y: -1200,
      z: -1990,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: false,
      backgroundColor: '#ffffff',
      userData: {
        arcadeStarted: false
      },
      iframeHtml: `
        <html>
          <head>
            <title>Inception Arcade Game</title>
            <style>
              body, html {
                margin: 0;
                padding: 0;
                overflow: hidden;
              }
            </style>
          </head>
          <body>
            <div style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%; background-color: #000000;">
              <div style="position: absolute; left: 0px; top: 150px; width: 100%; height: 300px;">
                <div style="position: absolute; left: 0px; top: 16px; width: 100%; height: 150px; color: #F80000; font-size: 74px; letter-spacing: -6px; text-shadow: 0 0 20px #ff0000; text-align: center; line-height: 150px; font-family: Tahoma, Arial; font-weight: bold; transform-origin: 50% 50%; transform: scale(1, 6) perspective(1000px) rotateX(80deg);">
                  inCEPTION
                </div>
                <div style="position: absolute; left: 0px; top: 12px; width: 100%; height: 150px; color: #F80000; font-size: 73px; letter-spacing: -5px; text-align: center; line-height: 150px; font-family: Tahoma, Arial; font-weight: bold; transform-origin: 50% 50%; transform: scale(1, 6) perspective(1000px) rotateX(80deg);">
                  inCEPTION
                </div>
                <div style="position: absolute; left: 0px; top: 8px; width: 100%; height: 150px; color: #F80000; font-size: 72px; letter-spacing: -4px; text-align: center; line-height: 150px; font-family: Tahoma, Arial; font-weight: bold; transform-origin: 50% 50%; transform: scale(1, 6) perspective(1000px) rotateX(80deg);">
                  inCEPTION
                </div>
                <div style="position: absolute; left: 0px; top: 4px; width: 100%; height: 150px; color: #F80000; font-size: 71px; letter-spacing: -3px; text-align: center; line-height: 150px; font-family: Tahoma, Arial; font-weight: bold; transform-origin: 50% 50%; transform: scale(1, 6) perspective(1000px) rotateX(80deg);">
                  inCEPTION
                </div>
                <div style="position: absolute; left: 0px; top: 0px; width: 100%; height: 150px; color: #FFDF00; font-size: 70px; letter-spacing: -2px; text-shadow: 0 0 3px #000000; text-align: center; line-height: 150px; font-family: Tahoma, Arial; font-weight: bold; transform-origin: 50% 50%; transform: scale(1, 6) perspective(1000px) rotateX(80deg);">
                  inCEPTION
                </div>
              </div>
              <div style="position: absolute; left: 0px; top: 400px; width: 100%; height: 50px; background-color: transparent; line-height: 50px; font-family: Tahoma, Verdana, sans-serif; font-size: 28px; transform: scale(1.5, 1); text-align: center; color: #ffffff; text-shadow: 0 0 10px #ffffff;">
                PRESS <span>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: inline-block; width: 30px; height: 30px;" fill="#ffffff" stroke="none">
                  <path d="M16.56,5.44L15.11,6.89C16.84,7.94 18,9.83 18,12A6,6 0 0,1 12,18A6,6 0 0,1 6,12C6,9.83 7.16,7.94 8.88,6.88L7.44,5.44C5.36,6.88 4,9.28 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12C20,9.28 18.64,6.88 16.56,5.44M13,3H11V13H13"></path>
                </svg></span> TO START
              </div>
            </div>
          </body>
        </html>
      `,
      init(html3d, panel) {
        panel.userData.arcadeStarted = false;
      }
    },
    {
      id: 'arcadeCabinetFrontTop',
      width: 1100,
      height: 150,
      x: 3000,
      y: -1400,
      z: -1650,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: true,
      backgroundColor: '#444444',
      innerHTML: `
        <div style="position: absolute; left: 0px; top: 10px; width: 1100px; height: 150px; color: #F80000; font-size: 74px; letter-spacing: -6px; text-shadow: 0 0 10px #000000; text-align: center; line-height: 150px; font-family: Tahoma, Arial; font-weight: bold; transform-origin: 50% 50%; transform: scale(1, 6) perspective(1000px) rotateX(80deg);">
          inCEPTION
        </div>
        <div style="position: absolute; left: 0px; top: 8px; width: 1100px; height: 150px; color: #F80000; font-size: 73px; letter-spacing: -5px; text-align: center; line-height: 150px; font-family: Tahoma, Arial; font-weight: bold; transform-origin: 50% 50%; transform: scale(1, 6) perspective(1000px) rotateX(80deg);">
          inCEPTION
        </div>
        <div style="position: absolute; left: 0px; top: 4px; width: 1100px; height: 150px; color: #F80000; font-size: 72px; letter-spacing: -4px; text-align: center; line-height: 150px; font-family: Tahoma, Arial; font-weight: bold; transform-origin: 50% 50%; transform: scale(1, 6) perspective(1000px) rotateX(80deg);">
          inCEPTION
        </div>
        <div style="position: absolute; left: 0px; top: 0px; width: 1100px; height: 150px; color: #F80000; font-size: 71px; letter-spacing: -3px; text-align: center; line-height: 150px; font-family: Tahoma, Arial; font-weight: bold; transform-origin: 50% 50%; transform: scale(1, 6) perspective(1000px) rotateX(80deg);">
          inCEPTION
        </div>
        <div style="position: absolute; left: 0px; top: -4px; width: 1100px; height: 150px; color: #FFDF00; font-size: 70px; letter-spacing: -2px; text-shadow: 0 0 3px #000000; text-align: center; line-height: 150px; font-family: Tahoma, Arial; font-weight: bold; transform-origin: 50% 50%; transform: scale(1, 6) perspective(1000px) rotateX(80deg);">
          inCEPTION
        </div>
      `,
      init(html3d, panel) {
        document.getElementById('arcadeCabinetFrontTop').style.backgroundImage = 'radial-gradient(#444444 60%, #4444ff 100%)';
      }
    },
    {
      id: 'arcadeCabinetFrontBottom',
      width: 1100,
      height: 220,
      x: 3000,
      y: -550,
      z: -1650,
      rotationX: 0,
      rotationY: 0,
      obstruction: true,
      interaction: true,
      backgroundColor: '#444444'
    },
    {
      id: 'arcadeCabinetFrontTopLeft',
      width: 350,
      height: 150,
      x: 3000,
      y: -1400,
      z: -2000,
      rotationX: 0,
      rotationY: -(Math.PI / 2),
      obstruction: false,
      interaction: true,
      backgroundColor: '#222222'
    },
    {
      id: 'arcadeCabinetFrontTopRight',
      width: 350,
      height: 150,
      x: 4100,
      y: -1400,
      z: -2000,
      rotationX: 0,
      rotationY: -(Math.PI / 2),
      obstruction: false,
      interaction: true,
      backgroundColor: '#222222'
    },
    {
      id: 'arcadeCabinetFrontTopTop',
      width: 1100,
      height: 350,
      x: 3000,
      y: -1250,
      z: -1650,
      rotationX: -(Math.PI / 2),
      rotationY: 0,
      obstruction: false,
      interaction: true,
      backgroundColor: '#111111'
    },
    {
      id: 'arcadeCabinetFrontBottomLeft',
      width: 350,
      height: 220,
      x: 3000,
      y: -550,
      z: -2000,
      rotationX: 0,
      rotationY: -(Math.PI / 2),
      obstruction: true,
      interaction: true,
      backgroundColor: '#222222'
    },
    {
      id: 'arcadeCabinetFrontBottomRight',
      width: 350,
      height: 220,
      x: 4100,
      y: -550,
      z: -2000,
      rotationX: 0,
      rotationY: -(Math.PI / 2),
      obstruction: true,
      interaction: true,
      backgroundColor: '#222222'
    },
    {
      id: 'arcadeCabinetFrontBottomTop',
      width: 1100,
      height: 350,
      x: 3000,
      y: -550,
      z: -2000,
      rotationX: (Math.PI / 2),
      rotationY: 0,
      obstruction: false,
      interaction: true,
      backgroundColor: '#111111'
    },
    {
      id: 'arcadeCabinetFrontBottomDescription',
      width: 600,
      height: 165,
      x: (3000 + 25), 
      y: -525,
      z: -1640,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: true,
      backgroundColor: '#111111',
      innerHTML: `
        <div style="width: 550px; margin-left: 15px; margin-top: 2px; color: #ffffff; font-size: 20px;" >
          <span style="font-size: 40px;">🛈</span><br />
          Click on the screen to give it focus. You can then move about the scene using your keyboard, by pressing WASD or arrow keys.
          Click outside the screen, such as on this text, to return focus and control to this scene.
        </div>
      `,
      init(html3d, panel) {
        const arcadeCabinetFrontBottomDescription = document.getElementById('arcadeCabinetFrontBottomDescription');
        arcadeCabinetFrontBottomDescription.style.visibility = 'hidden';
      }
    },
    {
      id: 'arcadeCabinetFrontBottomStartButton',
      width: 110,
      height: 110,
      x: (4100 - 135),
      y: -525,
      z: -1640,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: true,
      backgroundColor: 'transparent',
      innerHTML: `
        <div id="arcadeCabinetFrontBottomStartButton_div" title="Start or stop the game." style="position: absolute; left: 10px; top: 10px; width: 80px; height: 80px; border: 5px solid #FFDF00; border-radius: 60px; background-color: transparent; color: #ffffff; text-align: center; box-shadow: 0 0 15px #FFDF00;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="position: absolute; left: 15px; top: 15px; width: 50px; height: 50px;" fill="#ffffff" stroke="none">
            <path d="M16.56,5.44L15.11,6.89C16.84,7.94 18,9.83 18,12A6,6 0 0,1 12,18A6,6 0 0,1 6,12C6,9.83 7.16,7.94 8.88,6.88L7.44,5.44C5.36,6.88 4,9.28 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12C20,9.28 18.64,6.88 16.56,5.44M13,3H11V13H13"></path>
          </svg>
        </div>
      `,
      click(html3d, panel) {
        const arcadeIframe = html3d.panels.find((so) => so.id === 'arcadeCabinetIframe');
        if (arcadeIframe.userData.arcadeStarted !== true) {
          arcadeIframe.userData.arcadeStarted = true;
          arcadeIframe.element.style.pointerEvents = 'auto';
          arcadeIframe.element.style.userSelect = 'auto';
          arcadeIframe.iframe.srcdoc = pageCode;
          const arcadeCabinetFrontBottomStartButton_div = document.getElementById('arcadeCabinetFrontBottomStartButton_div');
          arcadeCabinetFrontBottomStartButton_div.style.border = '5px solid #55F755';
          arcadeCabinetFrontBottomStartButton_div.style.boxShadow = '0 0 15px #00F700';
          arcadeCabinetFrontBottomStartButton_div.style.textShadow = '0 0 8px #55F755';
          const arcadeCabinetFrontBottomDescription = document.getElementById('arcadeCabinetFrontBottomDescription');
          arcadeCabinetFrontBottomDescription.style.visibility = 'visible';
          const importButton = document.getElementById('arcadeCabinetFrontBottomImportSceneButton');
          importButton.style.visibility = 'visible';
          const exportButton = document.getElementById('arcadeCabinetFrontBottomExportSceneButton');
          exportButton.style.visibility = 'visible';
        } else {
          arcadeIframe.userData.arcadeStarted = false;
          arcadeIframe.element.style.pointerEvents = 'none';
          arcadeIframe.element.style.userSelect = 'none';
          arcadeIframe.iframe.srcdoc = arcadeIframe.iframeHtml;
          const arcadeCabinetFrontBottomStartButton_div = document.getElementById('arcadeCabinetFrontBottomStartButton_div');
          arcadeCabinetFrontBottomStartButton_div.style.border = '5px solid #FFDF00';
          arcadeCabinetFrontBottomStartButton_div.style.boxShadow = '0 0 15px #F77C00';
          arcadeCabinetFrontBottomStartButton_div.style.textShadow = '0 0 8px #F77C00';
          const arcadeCabinetFrontBottomDescription = document.getElementById('arcadeCabinetFrontBottomDescription');
          arcadeCabinetFrontBottomDescription.style.visibility = 'hidden';
          const importButton = document.getElementById('arcadeCabinetFrontBottomImportSceneButton');
          importButton.style.visibility = 'hidden';
          const exportButton = document.getElementById('arcadeCabinetFrontBottomExportSceneButton');
          exportButton.style.visibility = 'hidden';
        }
      }
    },
    {
      id: 'arcadeCabinetFrontBottomImportSceneButton',
      width: 280,
      height: 60,
      x: (3000 + 670), 
      y: -525,
      z: -1640,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: true,
      backgroundColor: 'transparent',
      innerHTML: `
        <div id="arcadeCabinetFrontBottomImportSceneButton_div" title="Make a copy of your current scene and set it as the game scene.\n\nNote: Everything in the game will be in the same state as your current scene. However, to prevent endless recursion, the state of the game-in-the-game is not carried on. You can start the game-in-the-game manually by clicking its start button." style="position: absolute; left: 10px; top: 10px; width: 240px; height: 60px; border: 5px solid #00FFDF; border-radius: 10px; background-color: transparent; box-shadow: 0 0 5px #00FFDF; text-shadow: 0 0 2px #00FFDF; cursor: pointer;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="position: absolute; left: 5px; top: 10px; width: 40px; height: 40px;" fill="#ffffff" stroke="none">
            <path d="M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z"></path>
          </svg>
          <div style="position: absolute; left: 60px; top: 10px; width: 180px; height: 40px; line-height: 20px; color: #ffffff; text-align: left; font-size: 18px; font-family: Arial; font-weight: bold; white-space: nowrap; overflow: hidden;">
            copy your scene<br />
            into the game
          </div>
        </div>
      `,
      init(html3d, panel) {
        const importButton = document.getElementById('arcadeCabinetFrontBottomImportSceneButton');
        importButton.style.visibility = 'hidden';
        const importButton_div = document.getElementById('arcadeCabinetFrontBottomImportSceneButton_div');
        importButton_div.addEventListener('click', () => {
          const iframeHtml3dInstance = html3d.panels.find(p => p.id === 'arcadeCabinetIframe').iframe.contentWindow?.html3dInstance;
          if (iframeHtml3dInstance) {
            const sceneData = html3d.export();
            iframeHtml3dInstance.import(sceneData);
          }
        });
      }
    },
    {
      id: 'arcadeCabinetFrontBottomExportSceneButton',
      width: 280,
      height: 60,
      x: (3000 + 670), 
      y: (-525) + 80,
      z: -1640,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: true,
      backgroundColor: 'transparent',
      innerHTML: `
        <div id="arcadeCabinetFrontBottomExportSceneButton_div" style="position: absolute; left: 10px; top: 10px; width: 240px; height: 60px; border: 5px solid #00FFDF; border-radius: 10px; background-color: transparent; box-shadow: 0 0 5px #00FFDF; text-shadow: 0 0 2px #00FFDF; cursor: pointer;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="position: absolute; left: 5px; top: 10px; width: 40px; height: 40px;" fill="#ffffff" stroke="none">
            <path d="M14 12L10 8V11H2V13H10V16M22 12A10 10 0 0 1 2.46 15H4.59A8 8 0 1 0 4.59 9H2.46A10 10 0 0 1 22 12Z"></path>
          </svg>
          <div style="position: absolute; left: 60px; top: 10px; width: 180px; height: 40px; line-height: 20px; color: #ffffff; text-align: left; font-size: 18px; font-family: Arial; font-weight: bold; white-space: nowrap; overflow: hidden;">
            teleport into the<br />
            game scene
          </div>
        </div>
      `,
      init(html3d, panel) {
        const exportButton = document.getElementById('arcadeCabinetFrontBottomExportSceneButton');
        exportButton.style.visibility = 'hidden';
        const exportButton_div = document.getElementById('arcadeCabinetFrontBottomExportSceneButton_div');
        exportButton_div.addEventListener('click', () => {
          const iframeHtml3dInstance = html3d.panels.find(p => p.id === 'arcadeCabinetIframe').iframe.contentWindow?.html3dInstance;
          if (iframeHtml3dInstance) {
            const sceneData = iframeHtml3dInstance.export();
            html3d.import(sceneData);
          }
        });
      }
    },
    {
      id: 'firstFloorTelevision',
      width: 1800,
      height: 1000,
      x: 1020,
      y: ((-(wallHeight + floorDepth)) - ((wallHeight / 2) + 500)),
      z: (-buildingDepth / 2) + 100,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: true,
      backgroundColor: '#000000',
      iframeSrc: 'about:blank',
      userData: {
        isOn: false
      },
      init(html3d, panel) {
        panel.userData.isOn = false;
      }
    },
    {
      id: 'firstFloorTelevisionControls',
      width: 160,
      height: 160,
      x: 2880,
      y: ((-(wallHeight + floorDepth)) - ((wallHeight / 2) + 80)),
      z: (-buildingDepth / 2) + 100,
      rotationX: 0,
      rotationY: 0,
      obstruction: false,
      interaction: true,
      backgroundColor: '#444444',
      innerHTML: `
        <div id="firstFloorTelevisionControls_onOffButton" title="Watch a YouTube video.\n\nAfter switching on, the video will not play automatically, you need to press play.\nAfter pressing play, click outside the video to regain keyboard movement control." style="position: absolute; left: 35px; top: 35px; width: 80px; height: 80px; border: 5px solid #FFDF00; border-radius: 60px; background-color: transparent; box-shadow: 0 0 15px #FFDF00;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="position: absolute; left: 15px; top: 15px; width: 50px; height: 50px;" fill="#ffffff" stroke="none">
            <path d="M16.56,5.44L15.11,6.89C16.84,7.94 18,9.83 18,12A6,6 0 0,1 12,18A6,6 0 0,1 6,12C6,9.83 7.16,7.94 8.88,6.88L7.44,5.44C5.36,6.88 4,9.28 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12C20,9.28 18.64,6.88 16.56,5.44M13,3H11V13H13"></path>
          </svg>
        </div>
      `,
      click(html3d, panel) {
        const firstFloorTelevision = html3d.panels.find((so) => so.id === 'firstFloorTelevision');
        const onOffButton = document.getElementById('firstFloorTelevisionControls_onOffButton');
        if (firstFloorTelevision.userData.isOn === false) {
          firstFloorTelevision.iframe.src = 'https://www.youtube.com/embed/BiQXFKYa-co?autoplay=0&mute=0&controls=1&loop=0';
          firstFloorTelevision.element.style.pointerEvents = 'auto';
          firstFloorTelevision.element.style.userSelect = 'auto';
          firstFloorTelevision.userData.isOn = true;
          onOffButton.style.border = '5px solid #55F755';
          onOffButton.style.boxShadow = '0 0 15px #00F700';
          onOffButton.style.textShadow = '0 0 8px #55F755';
        } else {
          firstFloorTelevision.iframe.src = '';
          firstFloorTelevision.element.style.pointerEvents = 'none';
          firstFloorTelevision.element.style.userSelect = 'none';
          firstFloorTelevision.userData.isOn = false;
          onOffButton.style.border = '5px solid #FFDF00';
          onOffButton.style.boxShadow = '0 0 15px #F77C00';
          onOffButton.style.textShadow = '0 0 8px #F77C00';
        }
      }
    }
  ]
};

window.html3dInstance = new HTML3D(document.getElementById('container'), scene_HTML3Ddemo);

// DOWNLOADLINKSTART
// This code is removed in the downloaded html file.
if (window.location.protocol === 'https:') {
  const headerpanel = document.getElementById('headerpanel');
  const headerpaneldownloadlink = document.createElement('div');
  Object.assign(headerpaneldownloadlink.style, {
    position: 'absolute',
    left: '430px',
    top: '0px',
    width: '400px',
    height: '40px'
  });
  headerpanel.appendChild(headerpaneldownloadlink);
  const downloadlink = document.createElement('div');
  downloadlink.title = 'HTML3D is a portable web app. All the JavaScript code is in the html file.\nClick here to download the html file.';
  Object.assign(downloadlink.style, {
    position: 'absolute',
    left: '10px',
    top: '8px',
    width: '400px',
    height: '24px',
    cursor: 'pointer'
  });
  headerpaneldownloadlink.appendChild(downloadlink);
  const downloadlink_svg = document.createElement('div');
  Object.assign(downloadlink_svg.style, {
    position: 'absolute',
    left: '0px',
    top: '0px',
    width: '24px',
    height: '24px',
    cursor: 'pointer'
  });
  downloadlink_svg.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 24px; height: 24px;">
      <path fill="#cccccc" d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" />
    </svg>
  `;
  downloadlink.appendChild(downloadlink_svg);
  const downloadlink_text = document.createElement('div');
  Object.assign(downloadlink_text.style, {
    position: 'absolute',
    left: '35px',
    top: '0px',
    width: '365px',
    height: '24px',
    color: '#cccccc',
    fontSize: '14px',
    lineHeight: '24px',
    whiteSpace: 'nowrap'
  });
  downloadlink_text.innerHTML = 'Download HTML3D';
  downloadlink.appendChild(downloadlink_text);
  let downloaded = false;
  downloadlink.addEventListener('click', async () => {
    if (downloaded) {
      return;
    }
    downloaded = true;
    downloadlink.title = '';
    downloadlink.style.cursor = 'default';
    downloadlink_svg.style.display = 'none';
    downloadlink_text.innerHTML = 'downloading HTML3D ...';
    try {
      const response = await fetch(window.location.href);
      let html = await response.text();
      html = html.replace(/\/\/ DOWNLOADLINKSTART[\s\S]*?\/\/ DOWNLOADLINKEND/g, '');
      const blob = new Blob([html], {type: 'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const dateYYYYMMDD = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      a.href = url;
      a.download = `html3d_${dateYYYYMMDD}.html`;
      a.click();
      URL.revokeObjectURL(url);
      downloadlink_text.innerHTML = 'downloaded to your Downloads folder';
      setTimeout(() => {
        downloadlink_text.innerHTML = '';
      }, 2000);
    } catch (error) {
      downloadlink_text.innerHTML = 'download error';
      setTimeout(() => {
        downloadlink_text.innerHTML = '';
      }, 2000);
    }
  });
}
// DOWNLOADLINKEND

</script>
</body>
</html>